[{"authors":null,"categories":null,"content":" Architecture  Build your first app  Developer guides  API reference   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1601048986,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"/keyple-website/docs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/","section":"docs","summary":" Architecture  Build your first app  Developer guides  API reference   ","tags":null,"title":"","type":"book"},{"authors":null,"categories":null,"content":" 0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core C++ component is compatible with PC and MAC platforms.\nDocumentation  Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"535a4d50826d3e1ebb341332d7e328dd","permalink":"/keyple-website/components-cpp/core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/core/","section":"components-cpp","summary":"0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core C++ component is compatible with PC and MAC platforms.\nDocumentation  Developer guide  Download All sources are available on GitHub.","tags":null,"title":"Keyple Core","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core Java component is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-core:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"d23fddcfea7cc187bdc78810a4b4527e","permalink":"/keyple-website/components-java/core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/core/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Core Java component is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.","tags":null,"title":"Keyple Core","type":"book"},{"authors":null,"categories":null,"content":" Core  Distributed systems  Card extensions  Reader plugins   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608050869,"objectID":"996124160146a6acb63a01dafdf69e19","permalink":"/keyple-website/components-java/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/","section":"components-java","summary":" Core  Distributed systems  Card extensions  Reader plugins   ","tags":null,"title":"Java","type":"book"},{"authors":null,"categories":null,"content":" Core  Card extensions  Reader plugins   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608050869,"objectID":"26e8dc5af429b27b1f4459d727d9ce75","permalink":"/keyple-website/components-cpp/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/","section":"components-cpp","summary":" Core  Card extensions  Reader plugins   ","tags":null,"title":"C++","type":"book"},{"authors":null,"categories":null,"content":" Local  Network  Remote   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"3431e2924ef3afa1de61b6e51287bd43","permalink":"/keyple-website/components-java/distributed-systems/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/distributed-systems/","section":"components-java","summary":" Local  Network  Remote   ","tags":null,"title":"Distributed systems","type":"book"},{"authors":null,"categories":null,"content":" Calypso   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"34dc2ca89e1162d78e18d2856b5a9349","permalink":"/keyple-website/components-cpp/extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/extensions/","section":"components-cpp","summary":" Calypso   ","tags":null,"title":"Card extensions","type":"book"},{"authors":null,"categories":null,"content":" Calypso   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"4d1974de8c75d398becc15f98ce75c0f","permalink":"/keyple-website/components-java/extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/extensions/","section":"components-java","summary":" Calypso   ","tags":null,"title":"Card extensions","type":"book"},{"authors":null,"categories":null,"content":" PC/SC  Stub   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"87792560adba323b25a954f72acc9f91","permalink":"/keyple-website/components-cpp/plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/plugins/","section":"components-cpp","summary":" PC/SC  Stub   ","tags":null,"title":"Reader plugins","type":"book"},{"authors":null,"categories":null,"content":" NFC  OMAPI  PC/SC  Stub   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1608113699,"objectID":"e8093af99e35c63fc539225c3b547fef","permalink":"/keyple-website/components-java/plugins/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/plugins/","section":"components-java","summary":" NFC  OMAPI  PC/SC  Stub   ","tags":null,"title":"Reader plugins","type":"book"},{"authors":null,"categories":null,"content":" Global Architecture  Keyple Core  Keyple Calypso   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1603814711,"objectID":"31bc0d9a3f9c6fcad90863cf851f2a50","permalink":"/keyple-website/docs/architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/architecture/","section":"docs","summary":" Global Architecture  Keyple Core  Keyple Calypso   ","tags":null,"title":"Architecture","type":"book"},{"authors":null,"categories":null,"content":" Java  Android  C\u0026#43;\u0026#43;   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607614011,"objectID":"36ddd4efffa8e3c0e47f29ae952caa4c","permalink":"/keyple-website/docs/build-your-first-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/build-your-first-app/","section":"docs","summary":" Java  Android  C\u0026#43;\u0026#43;   ","tags":null,"title":"Build your first app","type":"book"},{"authors":null,"categories":null,"content":" Common concepts  Centralized application  Distributed application  Calypso application  Create a plugin  Create an extension  Keyple Java 0.8.1 to 0.9.0   ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607614011,"objectID":"a7c9e10a31abdecaec5a338462a220a8","permalink":"/keyple-website/docs/developer-guide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/","section":"docs","summary":" Common concepts  Centralized application  Distributed application  Calypso application  Create a plugin  Create an extension  Keyple Java 0.8.1 to 0.9.0   ","tags":null,"title":"Developer guides","type":"book"},{"authors":null,"categories":null,"content":"JavaDoc The JavaDoc for the Keyple project is available online. The documentation is split into the following parts:\n 1.0.0 1.0.0-alpha-1 0.9.0 0.8.1  Modules    ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607614011,"objectID":"b5568d681972077a2a3f45e40a59d61a","permalink":"/keyple-website/docs/api-reference/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/api-reference/","section":"docs","summary":"JavaDoc The JavaDoc for the Keyple project is available online. The documentation is split into the following parts:\n 1.0.0 1.0.0-alpha-1 0.9.0 0.8.1  Modules    ","tags":null,"title":"API reference","type":"book"},{"authors":null,"categories":null,"content":"To add your support \u0026amp; trainings made a Pull request contributions on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"0c47d6fdeea7884d022b8c3c4803b35b","permalink":"/keyple-website/support-trainings/add-support-trainings/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/support-trainings/add-support-trainings/","section":"support-trainings","summary":"To add your support \u0026 trainings made a Pull request contributions on GitHub.","tags":null,"title":"Add your support \u0026 trainings","type":"support-trainings"},{"authors":null,"categories":null,"content":" 0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso C++ component is a Keyple reader extension for Calypso® technology.\nIt can be used on PC and MAC platforms.\nDocumentation   Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"f614eda1842c351b2492ba2a26b135b2","permalink":"/keyple-website/components-cpp/extensions/calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/extensions/calypso/","section":"components-cpp","summary":"0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso C++ component is a Keyple reader extension for Calypso® technology.\nIt can be used on PC and MAC platforms.","tags":null,"title":"Keyple Calypso","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso Java component is a Keyple extension for Calypso® technology.\nIt can be used on PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-calypso\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"896a617862a080db535c2ead654e82fa","permalink":"/keyple-website/components-java/extensions/calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/extensions/calypso/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Calypso Java component is a Keyple extension for Calypso® technology.\nIt can be used on PC, MAC and Android platforms.","tags":null,"title":"Keyple Calypso","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Local Java component is the part of the Keyple Distributed solution which contains all the local services.\nIt must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.\nIt is important to note that it uses and exposes the APIs exposed by Keyple Distributed Network component.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-plugin-remote-local:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-remote-local\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"36a22454706024bab7b6aaae05289716","permalink":"/keyple-website/components-java/distributed-systems/local/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/distributed-systems/local/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Local Java component is the part of the Keyple Distributed solution which contains all the local services.","tags":null,"title":"Keyple Distributed Local","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Network Java component is the part of the Keyple Distributed solution which contains the common network elements used by Keyple Distributed Local and Keyple Distributed Remote components.\nThis library should not be import explicitly because it\u0026rsquo;s imported by transitivity by the other components.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-plugin-remote-network:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-remote-network\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"3c25f7ea0ebea908a66dba7f87ee81b3","permalink":"/keyple-website/components-java/distributed-systems/network/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/distributed-systems/network/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Network Java component is the part of the Keyple Distributed solution which contains the common network elements used by Keyple Distributed Local and Keyple Distributed Remote components.","tags":null,"title":"Keyple Distributed Network","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin NFC Java component is a Keyple plugin for Android devices having NFC capabilities.\nIt is compatible with Android 4.4 minimum.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-android-plugin-nfc:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-nfc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"b4828565360c2328de7706d75bf0136a","permalink":"/keyple-website/components-java/plugins/nfc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/plugins/nfc/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin NFC Java component is a Keyple plugin for Android devices having NFC capabilities.","tags":null,"title":"Keyple Plugin NFC","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin OMAPI Java component is a Keyple plugin for Android devices using OMAPI technology.\nIt is compatible with Android 4.4 minimum.\nOMAPI (Open Mobile Application Programming Interface) is the mechanism which enables an authorized mobile app to communicate with applets within a SE in a device. This allows the app to benefit from enhanced SE-based security services.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-android-plugin-omapi:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-omapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"257a88e12a928ed3fd50fca5611e4e01","permalink":"/keyple-website/components-java/plugins/omapi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/plugins/omapi/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin OMAPI Java component is a Keyple plugin for Android devices using OMAPI technology.","tags":null,"title":"Keyple Plugin OMAPI","type":"book"},{"authors":null,"categories":null,"content":"Coming from a rather closed technical environment, ticketing for transport is essentially based on proprietary solutions provided by manufacturers. However, in order for the concept of Mobility as a Service to become a reality, and at a reasonable cost, the ecosystem should, as far as possible, rely on open standards, APIs and SDKs as well as Open Source technologies. This openness has already been a reality for several years in the field of passenger information and has enabled the explosion of rich and high-quality applications, thanks in particular to Open Data. Today, Eclipse Keyple™ is paving the way for ticketing to follow the same path, by making available for free the first fully Open Source API.\nEclipse Keyple™ accelerates the integration and development of ticketing applications by enabling multimodal transport services, public transport operators and event organizers to implement ticketing and access control systems based on a common, open and modular base.\nEclipse Keyple™ works with Keyple\u0026rsquo;s extensions. The first available extension allows you to benefit from Calypso®'s main features of reliability, security and interoperability.\nEclipse Keyple™ transforms complex contactless ticketing, transportation and event access systems into a simple integration to manage terminal readers and portals that use smart cards and mobile applications to enter and exit.\nAs an open source technology, Eclipse Keyple™ offers uniformity of structure but does not lock you into a specific ticketing system. Plugins and extensions are being created, or may be created by developers, to allow ticket processing integrating technologies other than Calypso®, based on several programming languages.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"282cad7c0a4930ebfdb0d9b1b88c4a4b","permalink":"/keyple-website/what-is-keyple/overview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/what-is-keyple/overview/","section":"what-is-keyple","summary":"Coming from a rather closed technical environment, ticketing for transport is essentially based on proprietary solutions provided by manufacturers. However, in order for the concept of Mobility as a Service to become a reality, and at a reasonable cost, the ecosystem should, as far as possible, rely on open standards, APIs and SDKs as well as Open Source technologies.","tags":null,"title":"Overview","type":"what-is-keyple"},{"authors":null,"categories":null,"content":" 0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC C++ component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.\nDocumentation   Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"3e098f2d7c27588a043ecdddf75ec704","permalink":"/keyple-website/components-cpp/plugins/pcsc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/plugins/pcsc/","section":"components-cpp","summary":"0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC C++ component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.","tags":null,"title":"Keyple Plugin PC/SC","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC Java component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-plugin-pcsc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"0c00de30fd4264a47a1208c470702537","permalink":"/keyple-website/components-java/plugins/pcsc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/plugins/pcsc/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin PC/SC Java component is a Keyple plugin for PC/SC smart card readers.\nIt is compatible with PC/SC Reader (Windows PC/SC WinScard API, Unix PC/SC lite API) equipment.","tags":null,"title":"Keyple Plugin PC/SC","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Remote Java component is the part of the Keyple Distributed solution which contains all the remote plugins.\nIt must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.\nIt is important to note that it uses and exposes the APIs exposed by Keyple Distributed Network component.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-plugin-remote-remote:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-remote-remote\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"783e0d90ad1a5448dc93ea045933417c","permalink":"/keyple-website/components-java/distributed-systems/remote/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/distributed-systems/remote/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Distributed Remote Java component is the part of the Keyple Distributed solution which contains all the remote plugins.","tags":null,"title":"Keyple Distributed Remote","type":"book"},{"authors":null,"categories":null,"content":" 0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub C++ component is a Keyple plugin used to stub smart card readers.\nIt is compatible with PC and MAC platforms.\nDocumentation   Developer guide  Download All sources are available on GitHub.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"cfcfcdd98a80f3b84a4dac3721d608b2","permalink":"/keyple-website/components-cpp/plugins/stub/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-cpp/plugins/stub/","section":"components-cpp","summary":"0.9.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub C++ component is a Keyple plugin used to stub smart card readers.","tags":null,"title":"Keyple Plugin Stub","type":"book"},{"authors":null,"categories":null,"content":" 1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub Java component is a Keyple plugin used to stub smart card readers.\nIt is compatible with PC, MAC and Android platforms.\nDocumentation   Developer guide JavaDoc API  Download All deliverables are available on the Maven Central Repository.\n Using Gradle  implementation 'org.eclipse.keyple:keyple-java-plugin-stub:1.0.0'   Using Maven  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-plugin-stub\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Direct download  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"a9d5f802f50e1a68bb69a44cc0ddefcf","permalink":"/keyple-website/components-java/plugins/stub/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/components-java/plugins/stub/","section":"components-java","summary":"1.0.0  Keyple project  Download  GitHub  Changelogs   Overview The Keyple Plugin Stub Java component is a Keyple plugin used to stub smart card readers.","tags":null,"title":"Keyple Plugin Stub","type":"book"},{"authors":null,"categories":null,"content":"Calypso Networks Association (CNA) is a non-profit organization dedicated to improve contactless electronic ticketing for transportation and access control standards since 2003. For many years, our mission has been to create innovative solutions that are fully interoperable, reliable, secure, and open.\nDiscover more about CNA here : http://calypsonet.org\nCalypso Networks Association offers comprehensive technical support and documentation to ensure all users can get the most out of Calypso® technology and Eclipse Keyple™.\nCalypso Networks Association provides a Calypso Test Kit. The Calypso Test Kit aims at helping ticketing system developers to fully experience Eclipse Keyple™ with a set of Calypso® SAM and Calypso® certified portable objects from several manufacturers in various configurations.\nFor many years, our mission has been to create innovative solutions that are fully interoperable, reliable, secure, and open. We collaborate with a dynamic network of city leaders and transport authorities that are keen to work with system integrators with Calypso® standard expertise.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"60d9ae5c79a12df7b726b9cd57698aab","permalink":"/keyple-website/support-trainings/cna/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/support-trainings/cna/","section":"support-trainings","summary":"Calypso Networks Association offers comprehensive technical support and documentation to ensure all users can get the most out of Calypso® technology and Eclipse Keyple™. ","tags":null,"title":"Calypso Networks Association","type":"support-trainings"},{"authors":null,"categories":null,"content":"Eclipse Keyple™ is an Eclipse open source project currently leaded by Calypso Networks Association, which has been the leader in contactless electronic ticketing transportation standards since 2003.\n     Free, easy-to-use and flexible Built by developers, for developers Tailored to public entities requirements     Interoperable with any smart card reader solution (standard/proprietary, local/remote) Open source libraries in Java and C++ Audit and certification   Compatible with any terminal architecture (mobile, embedded, server) Developer-friendly, up-to-date documentation, code samples and how-to guides Permanent compliance to the latest Calypso® release   Options for creating add-on features that incorporate Calypso’s advanced security together with non-Calypso smart cards for ticketing and payment Accredited and hosted by the Eclipse foundation Exchange platform between providers and transport authorities    Help desk-Separate maintenance for software and equipment Online and offline trainings available that will help you get the most of Keyple™    Active on GitHub and within the Eclipse community     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"b82f355f36579dc4f39c8ec384a1fc74","permalink":"/keyple-website/what-is-keyple/why-trust/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/what-is-keyple/why-trust/","section":"what-is-keyple","summary":"Eclipse Keyple™ is an Eclipse open source project currently leaded by Calypso Networks Association, which has been the leader in contactless electronic ticketing transportation standards since 2003.\n     Free, easy-to-use and flexible Built by developers, for developers Tailored to public entities requirements     Interoperable with any smart card reader solution (standard/proprietary, local/remote) Open source libraries in Java and C++ Audit and certification   Compatible with any terminal architecture (mobile, embedded, server) Developer-friendly, up-to-date documentation, code samples and how-to guides Permanent compliance to the latest Calypso® release   Options for creating add-on features that incorporate Calypso’s advanced security together with non-Calypso smart cards for ticketing and payment Accredited and hosted by the Eclipse foundation Exchange platform between providers and transport authorities    Help desk-Separate maintenance for software and equipment Online and offline trainings available that will help you get the most of Keyple™    Active on GitHub and within the Eclipse community     ","tags":null,"title":"Why trust Eclipse Keyple™?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"Whether you are a transport authority or operator, a mobility provider, a system integrator, an event manager, a mobility aggregator or a multi-mobility startup, Eclipse Keyple™ allows you to:\n Reduce your costs and accelerate your developments. Facilitate the integration of new services or technologies. Use libraries to enable instant payments, remote top-ups, event and multimodal transport integrations, connection to park-and-ride services, and more. Easily create applications or services compatible with existing card-centric or server-centric systems. Benefit from a more diverse and easily collaborative network that encourages coopetition in a multimodal market: compete where you can, collaborate when necessary to create integrated mobility customer journeys. Harness the flexibility to introduce modern, mobile and new architecture systems while maintaining integrations to legacy infrastructure. Ensure the sustainability and future-proofing of your ticketing system, as Keyple™ is compatible with any smart card reader and SIO-enabled terminal. Unchain from vendor lock in, black box and single provider systems to an open solution with access to multiple suppliers. Enable partnerships with multimodal transport, building facilities including parking, tourism operators and events to offer seamless, single ticketing across the end customer’s journey.  With Keyple Calypso extension:\n Have easy access to a highly secure and interoperable standard, Calypso®. Quickly build new apps and integrations that conform to the Calypso® standard and other ticketing schemas. Easily migrate from an existing, closed ticketing schemes to Calypso®, a high-end open ticketing, certified solution. Easily integrate with public transport providers that are using the Calypso® standard, today used in major cities around the world in over 25 countries.  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"619e8d908db818972b80664557c05715","permalink":"/keyple-website/what-is-keyple/who-is-it-for/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/what-is-keyple/who-is-it-for/","section":"what-is-keyple","summary":"Whether you are a transport authority or operator, a mobility provider, a system integrator, an event manager, a mobility aggregator or a multi-mobility startup, Eclipse Keyple™ allows you to:\n Reduce your costs and accelerate your developments.","tags":null,"title":"Who is it for?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"Calypso® is a set of specifications describing a fast and secure off-line contactless transaction, between a portable object and a terminal. It has been created for public transport ticketing at the end of the 1990s by some European public transport operators or authority (RATP and SNCF in Paris and all France, STIB in Brussels, OTLIS in Lisbon, ACTV in Venice, Konstanz in Germany), in order to create an open, interoperable and secure standard independent from industrials to ensure a real competition.\nToday Calypso® represents 20% of the world market of contactless smart ticketing in more than 25 countries and over 170 cities globally. It brings to his user a guarantee of security and interoperability which relies on a total compliance with existing standards (ISO 14443, ISO 7816-4, Global Platform). The Calypso® standard is managed by the Calypso Networks Association (CNA), which is led by transports operators and public authorities in order to ensure openness and independence from industrials in confront of other proprietary schemes.\nDiscover more about Calypso® here : https://calypsonet.org/solutions-overview/\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"891b6c07aee52d1deb466963c0da5e9a","permalink":"/keyple-website/what-is-keyple/what-is-calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/what-is-keyple/what-is-calypso/","section":"what-is-keyple","summary":"Calypso® is a set of specifications describing a fast and secure off-line contactless transaction, between a portable object and a terminal. It has been created for public transport ticketing at the end of the 1990s by some European public transport operators or authority (RATP and SNCF in Paris and all France, STIB in Brussels, OTLIS in Lisbon, ACTV in Venice, Konstanz in Germany), in order to create an open, interoperable and secure standard independent from industrials to ensure a real competition.","tags":null,"title":"What is Calypso®?","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"The goal of Eclipse Keyple™ is to allow developers to easily implement fast and secure off-line contactless transactions (using NFC cards, mobile phones, …) based on ticket processing integrating technologies other than Calypso®the Calypso standard.\nMore specifically, Keyple™ is a set of open source libraries that will initially be available in Java and C++, designed on the same mutual Object-Oriented Model compatible with any terminal architecture: mobile, embedded or server and Interoperable with any smart card reader solution: standard or proprietary, local or remote.\nTo fully understand how Keyple™ works, it is important to discern two main components of contactless ticketing technology:\n Smart Card Readers: Readers are situated at the entrance and exit of events, venues and transport sites. For example, a smart card reader could be a terminal, a portable scanning laser gun, or a swipe tablet area that is embedded into a door, vehicle or gate. Code is written for a terminal to set the parameters for allowing cards or apps to transmit ticketing information data. Sometimes in a distributed architecture system design, the code for the reader is not on the terminal, but in a cloud environment, so the reader sends the data to cloud-based architecture. Ticketing application: This is behind-the-scenes code that is able to take the data from the smart card reader and, in milliseconds real-time, analyze the balance of the ticket, confirm the permissions for entry, and update the data on the ticket (for example, to confirm that the ticket holder can enter the gate or vehicle, and then to deduct the cost of the journey and calculate the new balance).  According to this scheme, Keyple™ defines two layers:\n Smart Card readers are integrated through plugins implementing the SE Proxy API which manages the communications with a smart card through any type of contactless or contact reader (local, remote, standard, proprietary…) Ticketing applications relies on a high-level Calypso® processing API to manage Calypso® commands \u0026amp; security features. This API uses the SE Proxy API to communicate with the reader  Keyple™ comes with dedicated plugins that integrate directly with smart card readers that have been built on standard software interfaces including PC/SC, Android NFC reader, and Android OMAPI.\nIn cases where there is a distributed architecture design, Keyple™ includes a Remote API plugin so that a smart card terminal can be operated remotely, as if it were local to the terminal, and ensures that robust security and speed is not sacrificed in a cloud-based system.\nThe Calypso Processing API is also available as a Keyple™ extension. This component carries out the terminal processing element of ticketing technology. Access to Calypso’s security features are automatically managed by the Keyple™ extension.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607964312,"objectID":"bf786b8ea9088ea228a979a08534bfca","permalink":"/keyple-website/what-is-keyple/main-features/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/what-is-keyple/main-features/","section":"what-is-keyple","summary":"Keyple makes contactless ticketing accessible.","tags":null,"title":"Keyple's main features","type":"what-is-keyple"},{"authors":null,"categories":null,"content":"The API is currently divided in two major layers:\n The ‘Keyple Core' : a Secure Element Proxy API which allows managing SE readers in a generic way, whaterver the reader driver or environment, and for standalone or distributed solution ( Keyple Core User Guide). A ‘Calypso Keyple extension' : a high level Calypso Processing API allowing to operate commands with a Calypso Portable Object, and to manage a secure Calypso transaction ( Keyple Calypso User Guide).  Dedicated reader’s plugins have to be implemented in order to interface the SE Proxy API with the specific reader’s drivers.\nFor a distributed architecture, the Remote SE Plugin should be used (( Keyple Remote SE User Guide).)\nSupported platforms  Java SE 1.6 compact2 Android 4.4 KitKat API level 19  keyple-java repositories structure  Modules that are provided as artifacts  keyple-core: source and unit tests for the SE Proxy module (artifact : keyple-java-core) keyple-calypso: source and unit tests for the Calypso library (artifact : keyple-java-calypso) keyple-plugin: source and unit tests for the different plugins: smartcard.io PC/SC, Stub, Android NFC, Android OMAPI, etc.   developer support, testing  example: source for Keyple implementation examples, generic or Calypso specific.    Keyple features and corresponding packages Keyple features global for any Secure Element solution:\n   Features Packages     Selections of Secure Elements (high level API) org.eclipse.keyple.core.selection   Management of SE readers org.eclipse.keyple.core.seproxy   Notifications of reader plug/unplug, of SE insertion/removedefinition of automatic selection request in case of SE insertion on an Observable Reader. org.eclipse.keyple.core.seproxy.event   Communication protocols filters (setting for contactless/contacts SE Reader) org.eclipse.keyple.core.seproxy.protocol   Reader plugins implementation support Utility classes providing generic processing for SE Reader Plugins org.eclipse.keyple.core.seproxy.plugin   Transmition of grouped APDU commands to a SE Reader (low level API) org.eclipse.keyple.core.seproxy.message   SE specific library implementation support generic API to build a SE specific commands library org.eclipse.keyple.core.command    Keyple features defined to support the Calypso solution:\n   Features Packages     Calypso Portable Object commands and secure transaction management high level CalypsoAPI, commands’ settings are limited to functional parametersCalypso SAM (Secure Module) operations automatically processed org.eclipse.keyple.calypso.transaction   Calypso PO responses data parsing org.eclipse.keyple.calypso.command.po.parser   Calypso SAM responses data parsing org.eclipse.keyple.calypso.command.sam.parser   Calypso PO \u0026amp; SAM commands' setslow level Calypso API, commands’ settings include technical parameters specific to Calypso PO revisions or Calypso SAM revisions org.eclipse.keyple.calypso.commandorg.eclipse.keyple.calypso.command.poorg.eclipse.keyple.calypso.command.po.builderorg.eclipse.keyple.calypso.command.po.parser.sessionorg.eclipse.keyple.calypso.command.sam.parser.sessionorg.eclipse.keyple.calypso.command.sam.builderorg.eclipse.keyple.calypso.command.sam    Keyple packages and corresponding usages Depending on the targetting usage: implementation of a ticketing application (blue circle), a reader plugin (red circle), or a SE library (green circle), only specific Keyple packages must be imported.\n generic packages for any SE solution   specific packages for Calypso   Getting started Releases and snapshots are available from Maven central repositories.\nCloning this project Examples provided in this project relies on symbolic links to handle their common dependencies. (Please refer to this file for more information).\nAlthough symlink support should be provided out of the box for Unix users, Windows users should be aware that the git option core.symlinks needs to be enabled before cloning this repo. Several solutions can be considered:\n When installing git for Windows, an option Enable symbolic links can be choosen. If it has not been enabled and you want to set it via the installer, a reinstallation is needed If you do not want to reinstall git, this option can be enabled afterward via the command line git config core.symlinks true Also, the option can be enabled once only for this specific cloning operation with git clone -c core.symlinks=true REPO_URL  It is important to note that for this option to be actually working, the Windows user needs to have the SeCreateSymbolicLink permission: a user with admin rights is typically granted with this permission.\nImport keyple components with Gradle When using gradle, it is fairly simple to import Keyple components into your project. Just add the following statements to your build.gradle file :\nrepositories { //to import releases maven { url 'https://oss.sonatype.org/content/repositories/releases' } //to import snapshots maven {url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { //Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core implementation group: 'org.eclipse.keyple', name: 'keyple-java-core', version: '0.8.1' //Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso implementation group: 'org.eclipse.keyple', name: 'keyple-java-calypso', version: '0.8.1' //Import PCSC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc implementation group: 'org.eclipse.keyple', name: 'keyple-java-plugin-pcsc', version: '0.8.1' ... }  Artifacts The Eclipse Keyple Java artifacts are published on the Eclipse Keyple Project page [https://projects.eclipse.org/projects/iot.keyple/downloads] (available also on Maven).\n Keyple modules:  \u0026lsquo;Keyple Core module\u0026rsquo; JAR: the generic API to manage Secure Element Readers and to select SE application. \u0026lsquo;Keyple Calypso Library JAR\u0026rsquo;: the Calypso API to operate a transaction with a Calypso Portable Object.   Keyple plugins:  \u0026lsquo;Keyple PC/SC plugin JAR\u0026rsquo;: to manage PC/SC readers on a PC environment supporting the # javax.smartcardio API \u0026lsquo;Keyple NFC Android plugin AAR\u0026rsquo;: to operate the contactless reader of an Android Environment supporting the android.nfc API \u0026lsquo;Keyple OMAPI Android plugin AAR\u0026rsquo;: to operate the internal contacts readers of an Android Environment supporting the OMAPI \u0026lsquo;Keyple \u0026ldquo;stub\u0026rdquo; plugin JAR\u0026rsquo;: plugin to simulate the presence of fake readers with or without fake cards \u0026lsquo;Keyple \u0026ldquo;Remote SE\u0026rdquo; plugin JARs\u0026rsquo;: plugin \u0026amp; service to manage a SE remotely in a transparent way.    Building the Keyple components This guide helps developer that want to contribute to Keyple components base code. You can fork the project and contribute to it. Every contribution will be reviewed by the developper team and scan by our CI and quality code tools before being merged to the base code.\nJava components Prerequisites Here are the prerequisites to build the keyple components (jars)\n Java JDK 1.6, 1.7 or 1.8 (Java 11 is not supported yet) Maven (any version) available here Gradle (any version as we use the gradle wrapper) available here  Windows, Linux or Macos Following commands will build all the artifacts at once and install them into the local maven repository.\n./gradlew :installAll --info  Android components If you want to build the keyple android components (aar plugins), you need :\n Java JDK 1.6, 1.7 or 1.8 (Java 11 is not supported yet) Intellij 2018 community version or Android Studio 3.0 Android sdk 26 should be installed on your machine follow those instructions Gradle (any version as we use the gradle wrapper) available here  To acknowledge where is installed you Android SDK, you need to create a file local.properties in the /android, /android/example/calypso/nfc, /android/example/calypso/omapi folders with the following content sdk.dir=absolut/path/to/where/your/android/sdk/is\nFor instance sdk.dir=/Users/user/Library/Android/sdk\nLinux or Macos First, you need to build and install locally the java component keyple-core (see above) To build the plugins, execute the following commands in the /android folder, the first command is required to be executed at least once to build the gradle wrapper.\n./gradlew installPlugin  To build the example app NFC and OMAPI, first, you need to build and install locally the java component keyple-core, keyple-calypso and keyple-android-plugin (see above)\n./gradlew -b ./example/calypso/nfc/build.gradle assembleDebug ./gradlew -b ./example/calypso/omapi/build.gradle assembleDebug  Windows First, you need to build and install locally the java component keyple-core (see above) To build the plugins, execute the following commands in the /android folder, the first command is required to be executed at least once to build the gradle wrapper.\n.\\gradlew.bat installPlugin  To build the example app NFC and OMAPI, first, you need to build and install locally the java component keyple-core, keyple-calypso and keyple-android-plugin (see above)\n.\\gradlew.bat -b ./example/calypso/nfc/build.gradle assembleDebug .\\gradlew.bat -b ./example/calypso/omapi/build.gradle assembleDebug  CI and Docker Eclipse CI tools to build and test the components are Open Source too. They can be found in this repository : Eclipse Keyple Ops\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603814711,"objectID":"6ea3314fbbb656df6e3457a282dffc51","permalink":"/keyple-website/docs/architecture/keyple-global/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/architecture/keyple-global/","section":"docs","summary":"The API is currently divided in two major layers:\n The ‘Keyple Core' : a Secure Element Proxy API which allows managing SE readers in a generic way, whaterver the reader driver or environment, and for standalone or distributed solution ( Keyple Core User Guide).","tags":null,"title":"Global Architecture of Keyple","type":"book"},{"authors":null,"categories":null,"content":"This high-level API is convenient for developers implementing smart card processing application for terminal interfaced with smart card readers.\nPackages \u0026amp; features The Keyple Core User API is a tool to manage readers, and to select “generic” Secure Elements.\n  Features Packages   SE reader management Secure Element reader access org.eclipse.keyple.core.seproxy   Notifications of: reader plug/unplug, SE insertion/remove Definition of automatic selection request in case of SE insertion on an Observable Reader. org.eclipse.keyple.core.seproxy.event   Communication protocols filters (setting for contactless/contacts SE Reader) org.eclipse.keyple.core.seproxy.protocol   SE selection Generic selection of a Secure Element org.eclipse.keyple.core.selection   Secure Element transaction sequence – setting \u0026amp; selection A Secure Element transaction starts with the setting of plugins in order to choose the reader to communicate with SE.\nUsing a SE reader, depending on its capabilities, there can be two ways to select a SE through it:\n Either the processing of an “explicit selection”: if a SE is present in the reader, then the terminal directly operates a SE selection request through the reader. Otherwise if the reader is “observable”, the operating of a “default selection”: in this case a default selection request is defined on the reader, the terminal observes the reader, and wait to be notified by the reader about a SE insertion and selection.  At the end the terminal gets a selected SE, it can follow by operating APDU commands with the selected SE until the communication channel is kept open.\nThen a Keyple Core extension could be used to operates APDU commands with the selected SE solution.\n The Keyple Calypso extension provides a high-level API to defined ticketing processing involving Calypso cards, cf.: “Keyple Calypso User Guide”.\n Secure Element Proxy Service API – readers management Using the Keyple Core, Secure Element Readers (SeReader) are managed through plugins (ReaderPlugin).\nThe active plugins are registered to the SE Proxy Service (the singleton SeProxyService).\n Each plugin is registered through a unique name to the SE Proxy Service. Each reader of a plugin is also defined with a unique name inside the plugin.  Plugin setting To secure the usage of the SE Proxy API for the development of terminal applications, the internal implementation of plugins (classes SpecificPluginImpl \u0026amp; SpecificReaderImpl) is hidden.\n For a specific plugin, only the plugin \u0026amp; reader interfaces (SpecificPlugin \u0026amp; SpecificReader) and the factory (class SpecificPluginFactory) are public. The factory of a plugin is set to register a specific plugin to the SE Proxy Service.  Most of plugins of local readers of Keyple are defined as singleton with a unique instance (e.g.: PC/SC, Android NFC, Android OMAPI, most of embedded readers).\nFor the Remote SE plugin defined to manage remote readers, specific plugin instances are created for each communication interfaces.\nSE readers’ access The SE Proxy Service allows to get all the list of the active plugins. A specific plugin could also be directly recovered through its name.\nIn the same way, a plugin can provide the list of all the plugged readers.\nDepending on the native reader technology, some specific parameters could be defined at the plugin or reader level.\nFor a classic plugin, the number of readers is determinate, all the plugged readers of the plugin are directly available for the SE Proxy Service.\nSupport of reader farm or HSM For systems based on a centralized security, in order to manage multiple remote terminal in parallel, central servers could requires to interface a huge number (several hundreds or thousands) of SE through a farm of readers or HSM (Hardware Security Module: an electronic board able to emulate multiple SE).\n The multitude of embedded SE could be divided in different groups of profiles. An HSM is often shared between several services, so the full set of readers isn\u0026rsquo;t directly available for a service, a service has to request the allocation of a reader from a specific group.  The SE Proxy Service could support reader farm or HSM though plugins managing \u0026ldquo;pool\u0026rdquo; of readers (ReaderPoolPlugin).\n At the initialization, the list of reader is empty. The list is be filled depending on the reader allocations requested. When not more required, a reader could be released from the pool.  All plugins have to implement the interface ReaderPlugin and SeReader. A plugin managing a pool of reader should implement in addition the interface ReaderPoolPlugin.\nSE presence check \u0026amp; “explicit selection transaction” A SE reader has the capability to check is a SE is present or not.\n For SE terminal processing for which the presence of a SE in a reader is \u0026ldquo;static' during a transaction, the transaction starts in general with the verification of the SE presence. If the SE is present, the transaction can continue with the selection of the SE. We call this kind of transaction: an \u0026ldquo;explicit selection transaction\u0026rdquo;.\n Plugin \u0026amp; Reader events For some SE terminal, the processing is dynamically driven by the insertion/remove of a SE in a reader, or by the plug/unplug of a reader.\nE.g., in transportation, the ticketing transaction of access control gates is often started when a contactless card is detected in the field of the reader. For that, in Keyple, a SE reader or a plugin has to be observable.\nA plugin could be optionally observable (by implementing ObservablePlugin).\n In this case a terminal application could observe the plugin (by implementing PluginObserver) in order to be notified (PluginEvent) when a new reader is plugged to the plugin, or when a referenced reader is unplugged. To receive the notification of a specific plugin, the plugin observer should first be added to the observer list of the observable plugin.  Depending on the capability of the plugin, a reader could be optionally observable (by implementing ObservableReader).\n A terminal application could observe the plugin (by implementing ReaderObserver) in order to be notified (ReaderEvent) when a SE is inserted or removed from a specific. The reader observer should be added to the observer list to receive the notifications the observable reader.  By default, an observable reader notifies only the insertion or the remove of a SE.\nPlugin observability activation An observable plugin automatically starts to observe plugin events when at least one plugin observer is registered and stops the listening when the last plugin observer is removed.\nAutomatic selection \u0026amp; “default selection transaction” On an observable reader, there is in addition the possibility to define a \u0026ldquo;default selection operation\u0026rdquo;: in this case, when a SE is inserted, the observable reader tries automatically to select the inserted SE using the defined default setting.\n If the inserted SE is successfully selected, then the observable reader notifies that \u0026ldquo;an inserted SE has matched the default selection\u0026rdquo; and provides the corresponding response. Otherwise if the observable reader failed to select the inserted SE, it could just notify that a SE has been inserted.   For SE terminal for which the processing is \u0026ldquo;dynamically\u0026rdquo; driven by the presence of a SE in a reader, the transaction starts in general with the detection of the insertion of a SE and its automatic selection. The reader observer is then notified to analyze the response of the selected SE, and to continue the transaction with the SE. We call this kind of transaction: a \u0026ldquo;default selection transaction\u0026rdquo;.\n Reader notification modes If no default selection is defined, an observable reader notifies its observers for “SE insertion” (whatever the SE detected) or “SE removed” events. A default selection could be defined for the “always” or the \u0026ldquo;matched only” notification mode.\n In the always mode, if the inserted matches the default selection, the observers are notified about a “SE matched” event, otherwise an “SE insertion” event is notified. In case of \u0026ldquo;matched only” mode, the observable reader doesn’t notify SE insertion event. The reader observer will be notified only if a default selection succeed on the observable reader; this configuration allows the reader observer to skip the processing of wrong SE insertions.  Reader observability activation, “polling mode” \u0026amp; “SE removal procedure” For an observable reader, the listening of reader event requires also the registration of at least one reader observer.\nAn observable reader could switch between four internal states: “Wait for start detection”, “Wait for SE insertion”, “Wait for SE processing”, “Wait for SE removal”.\n At the wait for start detection, the observable reader doesn’t notify any event. The start of the SE detection by an observable reader need to be explicitly requested by an observer by setting a “polling mode” either through a ‘startSeDetection’ or a ‘setDefaultSelectionRequest’ commands. The SE detection could be started for polling mode defined either in “single shot” or “repeating” mode.  In single shot mode, the observable reader stops the detection after the SE removal (back to the wait for start detection). In repeating mode, after the SE removal, the observable reader restart to detect another SE (back to the wait for SE insertion).   Wait for SE insertion, if a SE is inserted or selected, the registered reader observers are notified by the observable reader according to the defined notification mode. The observable reader switches to the wait for SE processing. During the SE processing by the observers, the observable reader waits that an observer acknowledges the end of the SE processing. There are two waits to ends the processing of an observed SE:  Either an observer directly could stop the listening of the observable reader (‘stopSeDetection’ command). The observable reader switches to the wait for start detection, and the observers are immediately notified about the SE remove. Otherwise, the observers could wait for a clean remove of the SE from the observable reader; it’s the SE removal sequence:  When the main reader observer has finished the processing of the SE, it could request the observable reader to wait for the remove of the SE (‘notifySeProcessed’ command). Finally, the reader observers could be notified when the SE is effectively removed. If the SE insertion listening started in the \u0026ldquo;repeating polling mode\u0026rdquo;, then when the SE is removed, the observable reader automatically starts again the listening of a new SE insertion; otherwise a new explicit request to start the SE listening is required to restart the listening.      Secure Element Selection API Selection parameters (Communication protocol, ATR, AID) To select a Secure Element, a SE Selector has to be defined, based on one to three parameters.\n A SE selection could be defined for a specific communication protocol. A SE could be filtered for an ATR (Answer To Reset) matching a specific regular expression. A specific application of a SE could be selected by setting its AID (Application IDentifier).  Selection transaction To operate a transaction with a SE, it should be firstly selected. The aim of the SE selection API is to get a SE resource: a set of a reader with a selected SE.\nA SE Selection is managed in two steps:\n first the “preparations” of selection request based on SE selector, next the “processing” of the selection requests.  In order to manage multiple kinds of SE, several selection requests could be prepared with different selectors.\nDepending on the setting of the reader, the processing of the selection could be operated in two different ways:\n either in a “explicit” way after the checking of the SE presence, or in a ”default” way for an observable reader detecting the insertion of a SE.   cf. “Generic Use Case 1 / Explicit AID Selection” example\ncf. “Generic Use Case 2 / Default Selection Notification” example\n In case a SE Selection is prepared with a channel control mode defined as “keep open”, then the different prepared selectors are operated with the presented SE, but the processing of the selection stops when a selector matches the SE.\n The result of the SE selection could be a single ‘matching SE’: this SE is kept as selected in the reader. It’s possible to directly operate command with the SE.  But if a SE selection has been defined with a channel control mode at “close after”, in this case all the prepared SE selectors are operated whatever the matching result.\n After each selector processing, if a selector has matched, the logical channel with the SE is closed (the SE is no more selected). If several applications of the presented SE have matched the selectors: the result of the processing of SE selections is a list matching SE, but all of them are deselected. To continue the SE processing, the terminal application has to choose one matching SE, and to select it again but in “keep open” channel control mode.   cf. “Generic Use Case 3 / Grouped Multi-Selection” example\n After the selection of a SE, using a SE resource, the terminal can continue by operating a specific transaction with the corresponding SE.\n cf. “Generic Use Case 4 / Sequential Multi-Selection” example\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603814711,"objectID":"ab9ddb1d301e4f8e2308e0076ac779a6","permalink":"/keyple-website/docs/architecture/keyple-core/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/architecture/keyple-core/","section":"docs","summary":"This high-level API is convenient for developers implementing smart card processing application for terminal interfaced with smart card readers.\nPackages \u0026amp; features The Keyple Core User API is a tool to manage readers, and to select “generic” Secure Elements.","tags":null,"title":"Keyple Core Architecture","type":"book"},{"authors":null,"categories":null,"content":"Packages \u0026amp; features The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Object securely using Calypso SAM:\n The generic Secure Element selection is enhanced for the selection of a Calypso PO. The FCI response is automatically analyzed in order to identify the revision and the features supported by the Calypso PO. The invalidation status is also checked. The selected Calypso PO object allows to automatically initialize a Calypso PO transaction: high level functional commands could be prepared and processed in order to read or write data in the PO file structure, outside or securely inside a Calypso secure session.    Features Packages   Calypso PO operations Selection of Calypso SE: PO or SAM PO transaction: Read / update of data PO authentication org.eclipse.keyple.calypso.transaction   Calypso PO responses data parsing org.eclipse.keyple.calypso.command.po.parser   Calypso Selection The Calypso API to select a Portable object is an extension of the generic Secure Element selection Core API:\n A PO AID selection could be defined to accept or reject invalidated PO. A request for a SE selection is defined with SE selector containing at least an AID (to operate through a Select Application APDU command) or an ATR filter. A request for a PO selection could be enhanced to operate after the PO selector processing some APDU commands with the PO : Select File or Read Records commands. In case of successful Calypso PO, the matching SE is retuned as a Calypso PO. The Calypso API analyzes the startup information of a Calypso PO in order to identify the kind of product, its revision, the optional features supported, the file structure used. Then for coming PO commands, the setting of the technical parameters automatically managed.  The PO command grouped with the PO selection have to be “prepared” before the processing of a default or explicit SE selection.\n cf. “Calypso Use Case 1 / Explicit AID Selection” example\ncf. “Calypso Use Case 2 / Default Selection Notification” example\n A ‘PO resource’ is the set of a Calypso PO and the reader on which it is selected.\nIn a same way the Calypso APO provides the tool to select a Calypso security module (a SAM). A SAM selector doesn’t support AID. The corresponding matching SE is a Calypso SAM. A Calypso SAM and the reader used for its selection defines a ‘SAM resource’.\nCalypso secure transaction A PO transaction could be operated on a Calypso resource. In case a SAM resource is set, a PO transaction could support the Calypso secure session in order to manage a mutual authentication between the terminal and the Calypso PO.\nThrough the PO transaction API, only the APDU commands for the PO are explicitly defined; the APDU commands for the SAM are automatically built by the library. Two kinds of methods are provided by the API: ‘prepare’ methods, and ‘process’ methods.\n The ‘prepare’ methods allows to define PO file selection and PO data access operations (read or update of records for a specific file, append of record for a cyclic file, increase or decrease of the value of a counter). A ‘process” method sends to the PO at least the previously prepared command.  The process PO commands method could operated only if no secure session is currently open with the PO. If one or several PO commands have been prepared, a single request is done to the PO reader. The process opening method allows to manage the opening of a secure session.  First a single request is operated to the SAM reader in order to set the PO serial as the cryptographic diversifier, and to get the terminal challenge for the session. Then another single request is done to the PO reader to play the prepared PO command, and to manage the opening of the PO session.   A process PO command in session method could be processed only if a secure session is already open with PO.  A single request Is operated with the PO reader to operate the prepared PO commands. Another single request is sent to the SAM reader to update the update the digest of the MAC session.   The process closing method is used to manage the closing of the secure session with the PO.  A first SAM request is operated to update the digest of the last prepared PO commands and to get the terminal session certificate (to save a PO request, the API anticipates the responses of the prepared PO commands). A single PO request is transmitted to run the last prepared PO command, to recover the PO session certificate, and to send the ratification signal if necessary. Finally, a second SAM request allows to authenticate the PO. If the transaction is successful the mutual authentication is valid, and the PO has atomically committed the requested data updates.      The minimal costs of a Calypso secure session are:\n 3 PO requests (1 for the PO selection + 1 for the PO session opening + 1 for the PO session closing). And 3 SAM requests if the SAM is already selected (1 for the PO session opening + 2 for the PO session closing); otherwise 4 SAM requests if the SAM isn’t already selected.  By default, the PO transaction manages the Calypso secure session as ‘atomic’: the cumulative amount of PO updates command can’t exceed the size of the PO session buffer.\n cf. “Calypso Use Case 4 / PO Authentication” example\n The PO transaction could also be defined to allow multiple sessions: in this case the transaction is automatically split in several session as necessary.\n cf. “Calypso Use Case 5 / PO Multiple Session\u0026quot; example\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603814711,"objectID":"dbd01d0e9390470da13203692a071540","permalink":"/keyple-website/docs/architecture/keyple-calypso/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/architecture/keyple-calypso/","section":"docs","summary":"Packages \u0026amp; features The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Object securely using Calypso SAM:\n The generic Secure Element selection is enhanced for the selection of a Calypso PO.","tags":null,"title":"Keyple Calypso Architecture","type":"book"},{"authors":null,"categories":null,"content":" This quick start describes how to create a ready-to-execute Java command-line application that runs a simple Calypso card-based transaction involving two readers.\n The demonstration application created for this quick start requires a Calypo card and a Calypo SAM.   We will use three main components of Keyple:\n  Keyple Core which is the base component to which all the others refer,  Keyple PC/SC plugin to provide the ability to manage PC/SC readers,  Keyple Calypso extension to handle the commands sent to the Calypso Portable Object (PO) and the Secure Access Module (SAM).  In this guide Gradle is used as build automation tool, but it is easy to transpose these explanations to another tool such as Maven for example.\nThe example can run on any machine: Linux, Windows and macOS. If not installed in your machine, you will need to download :\n Java 1.6 or newer  Gradle (any version)  We recommend that you use a Java IDE like Eclipse or Intellij IDEA to create your new Gradle project.\nCreate a Gradle-based empty project Create a new Java project and add the following statements to your build.gradle file to import the Keyple components into your project:\napply plugin: 'java' repositories { mavenCentral() } dependencies { //Keyple core is a mandatory library for using Keyple, in this case import the last version of keyple-java-core implementation 'org.eclipse.keyple:keyple-java-core:1.0.0' //Import Calypso library to support Calypso Portable Object, in this case import the last version of keyple-java-calypso implementation 'org.eclipse.keyple:keyple-java-calypso:1.0.0' //Import PC/SC library to use a Pcsc reader, in this case import the last version of keyple-java-plugin-pcsc implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0' //Import logger lib implementation 'org.slf4j:slf4j-api:1.7.25' implementation \u0026quot;org.slf4j:slf4j-simple:1.7.25\u0026quot; }  If necessary, also create the usual tree in which the Java code of this guide will be placed, namely the folders: \\src\\main\\java\nLet\u0026rsquo;s code Now let\u0026rsquo;s see step by step how to create in one single class the elements that allow a certified reading of data through a Calypso secure session.\nIn a real ticketing application, the organization of the code would probably be different, but the point here is to show how Keyple makes it possible to perform very simply operations that normally require a quantity of code and knowledge that far exceeds what is implemented here.\nYou can either progressively copy each of the small portions of code that follow or copy the whole class at the bottom of this page.\nCreate the class skeleton and configure the PC/SC plugin and the readers The first step to use Keyple SDK is to initialize the plugin and smart card readers.\nCopy the source code below in a new Java Class named DemoPoAuthentication.\nIn this snippet the PC/SC plugin is registered to the SmartCardService.\nTwo readers needs to be connected to the local machine. Replace \u0026ldquo;PO_READER_NAME\u0026rdquo; and \u0026ldquo;SAM_READER_NAME\u0026rdquo; with the name of the USB readers.\nIf you don’t know the reader\u0026rsquo;s names, read the FAQ.\nimport org.eclipse.keyple.calypso.command.sam.SamRevision; import org.eclipse.keyple.calypso.transaction.*; import org.eclipse.keyple.core.card.selection.*; import org.eclipse.keyple.core.service.*; import org.eclipse.keyple.core.util.ByteArrayUtil; import org.eclipse.keyple.plugin.pcsc.*; public class DemoPoAuthentication { public static void main(String[] args) { // Get the instance of the SmartCardService : main service of Keyple SDK SmartCardService smartCardService = SmartCardService.getInstance(); // Register the PcscPlugin within the SmartCardService to use PC/SC readers Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory()); // Get the PO reader PcscReader poReader = (PcscReader) plugin.getReader(\u0026quot;PO_READER_NAME\u0026quot;); // Configure the PO reader parameters poReader.setContactless(true); // Get the SAM reader PcscReader samReader = (PcscReader) plugin.getReader(\u0026quot;SAM_READER_NAME\u0026quot;); // ... } }  Select the SAM Before executing a transaction each smart card should be selected. The next step is the selection of the SAM smart card resulting in a CalypsoSam object.\nIt is then combined with the SAM reader to form the SAM resource needed later within the transaction service.\n// Prepare a SamSelector that identifies the Calypso SAM SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build(); // Perform the SAM selection CardSelection samSelection = new CardSelection(); samSelection.prepareSelection(new SamSelectionRequest(samSelector)); if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader.getName()); } SelectionsResult selectionsResult = samSelection.processExplicitSelection(samReader); if (!selectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } CalypsoSam calypsoSam = (CalypsoSam) selectionsResult.getActiveSmartCard(); // Associate the calypsoSam and the samReader to create a samResource CardResource\u0026lt;CalypsoSam\u0026gt; samResource = new CardResource\u0026lt;\u0026gt;(samReader, calypsoSam); //...  Select the PO 1st PO exchange:\nThe PO selection is made using the application\u0026rsquo;s AID and results in a CalypsoPo object that will contain all the information extracted from the PO all along the transaction.\n// Prepare a Calypso PO selection final String AID = \u0026quot;315449432E49434131\u0026quot;; /* AID: Keyple test kit profile 1, Application 2 */ CardSelection seSelection = new CardSelection(); // Setting up a selection based on the AID of a Calypso Revision 3.1 PO // // Select the first application matching the selection AID whatever the card communication protocol PoSelectionRequest poSelectionRequest = new PoSelectionRequest( PoSelector.builder() .aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier .invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not .build()); // Add the selection case to the current selection // (we could have added other cases) seSelection.prepareSelection(poSelectionRequest); if (!poReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;The selection of the PO has failed.\u0026quot;); } // Perform the PO selection and get a CalypoPo container in return CalypsoPo calypsoPo = (CalypsoPo) seSelection.processExplicitSelection(poReader).getActiveSmartCard(); //...  Opening the secure session 2nd PO exchange :\nThe secure session opening operated by the PoTransaction service is combined with the reading of the environment file (SFI=07h).\nThe PO/SAM mutual authentication process is initiated transparently.\n// Prepare the security settings used during the Calypso transaction PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build(); // Create a PoTransaction service to manage the Calypso transaction PoTransaction poTransaction = new PoTransaction( new CardResource\u0026lt;\u0026gt;(poReader, calypsoPo), poSecuritySettings); final byte RECORD_NUMBER_1 = 1; final byte SFI_Environment = (byte) 0x07; // Schedule the reading of the Environment file after the secure session is opened // (we could have added other commands) poTransaction.prepareReadRecordFile( SFI_Environment, // the sfi to select RECORD_NUMBER_1); // Perform the session opening with the debit key poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the Environment data from the card image CalypsoPo ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment); String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent()); System.out.println(\u0026quot;Environment file content: \u0026quot;+ environmentLog); //...  Transaction : close session 3rd PO exchange:\nSimply close the secure session.\nThe mutual authentication is finalized, it includes the authentication of the data in the read file.\nNote: any technical, crytographic or content-related incident in the PO would be signalled by an exception and would interrupt the thread of execution.\n// Schedule the closure of the channel with the PO after the closing of the secure session poTransaction.prepareReleasePoChannel(); // Perform the closing of the Calypso Secure Session poTransaction.processClosing(); System.out.println(\u0026quot;The data read in session have been certified by the successful closing.\u0026quot;); //...  Finally unregister the plugin before shutting down the application\n// Shutdown the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0);  Find the complete code source below.\nRun  Connect two USB PC/SC Readers. Insert the SAM smart card in the SAM reader. Insert the PO smart card in the PO reader. Run the application.   All project dependencies, including Keyple components, are downloaded during the first run, which can take some time.   FAQ How do I find out the names of the readers?\nTo find out the names of the readers connected to your computer, we will use Keyple with the following class which prints in the console the number and names of the readers present:\nimport org.eclipse.keyple.core.service.Plugin; import org.eclipse.keyple.core.service.SmartCardService; import org.eclipse.keyple.plugin.pcsc.PcscPluginFactory; import java.util.Set; public class ReaderDiscovery { public static void main(String[] args) { SmartCardService smartCardService = SmartCardService.getInstance(); Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory()); Set\u0026lt;String\u0026gt; names = plugin.getReaderNames(); System.out.println(names.size() + \u0026quot; readers found.\u0026quot;); for (String name : names) { System.out.println('\u0026quot;' + name + '\u0026quot;'); } } }  The console output should look something like:\n2 readers found. \u0026quot;ASK LoGO 0\u0026quot; \u0026quot;Identive CLOUD 2700 R Smart Card Reader 0\u0026quot;  Identify which reader will be the PO (contactless) reader and the SAM (contact) reader and replace PO_READER_NAME and SAM_READER_NAME with their values.\nHow to activate the Keyple\u0026rsquo;s logs?\nAs soon as the slf4j library is imported into the project, Keyple modules are able to produce logs.\nHowever, to take full advantage of the possibilities of this library, it is necessary to create a simplelogger.properties file in the /src/main/resources folder of the project.\nThe self-documented content of this file may be:\n# SLF4J's SimpleLogger configuration file # Simple implementation of Logger that sends all enabled log messages, for all defined loggers, to System.err. # Default logging detail level for all instances of SimpleLogger. # Must be one of (\u0026quot;trace\u0026quot;, \u0026quot;debug\u0026quot;, \u0026quot;info\u0026quot;, \u0026quot;warn\u0026quot;, or \u0026quot;error\u0026quot;). # If not specified, defaults to \u0026quot;info\u0026quot;. org.slf4j.simpleLogger.defaultLogLevel=debug # Logging detail level for a SimpleLogger instance named \u0026quot;xxxxx\u0026quot;. # Must be one of (\u0026quot;trace\u0026quot;, \u0026quot;debug\u0026quot;, \u0026quot;info\u0026quot;, \u0026quot;warn\u0026quot;, or \u0026quot;error\u0026quot;). # If not specified, the default logging detail level is used. #org.slf4j.simpleLogger.log.xxxxx= # Set to true if you want the current date and time to be included in output messages. # Default is false, and will output the number of milliseconds elapsed since startup. org.slf4j.simpleLogger.showDateTime=true # The date and time format to be used in the output messages. # The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat. # If the format is not specified or is invalid, the default format is used. # The default format is yyyy-MM-dd HH:mm:ss:SSS Z. org.slf4j.simpleLogger.dateTimeFormat=[HH:mm:ss:SSS] # Set to true if you want to output the current thread name. # Defaults to true. org.slf4j.simpleLogger.showThreadName=true # Set to true if you want the Logger instance name to be included in output messages. # Defaults to true. org.slf4j.simpleLogger.showLogName=false # Set to true if you want the last component of the name to be included in output messages. # Defaults to false. org.slf4j.simpleLogger.showShortLogName=true org.slf4j.simpleLogger.levelInBrackets=true  Why do I see a warning in the console about illegal reflexive access when running the application?\nA known problem on Windows 8/10 platforms causes the smartcard service to stop when the last reader is removed. This problem prevents a \u0026ldquo;classic\u0026rdquo; monitoring of connections and disconnections of readers with the smartcard.io library (Java PC/SC). So for the moment we are using a workaround based on reflexivity to overcome this problem and allow a correct monitoring of the readers in the PC/SC plugin. This has the disadvantage of generating a warning message with recent versions of the JVM. However, we have not found any problems with this implementation of the PC/SC plugin so far.\nFull code Here is the complete code of this quick start in one single block.\nimport org.eclipse.keyple.calypso.command.sam.SamRevision; import org.eclipse.keyple.calypso.transaction.*; import org.eclipse.keyple.core.card.selection.*; import org.eclipse.keyple.core.service.*; import org.eclipse.keyple.core.util.ByteArrayUtil; import org.eclipse.keyple.plugin.pcsc.*; public class DemoPoAuthentication { public static void main(String[] args) { // Get the instance of the SmartCardService : main service of Keyple SDK SmartCardService smartCardService = SmartCardService.getInstance(); // Register a PcscPlugin within the SmartCardService to use PC/SC USB Readers Plugin plugin = smartCardService.registerPlugin(new PcscPluginFactory()); // Get the PO reader PcscReader poReader = (PcscReader) plugin.getReader(\u0026quot;ASK LoGO 0\u0026quot;); // Configure the PO reader parameters poReader.setContactless(true); // Get a SAM reader PcscReader samReader = (PcscReader) plugin.getReader(\u0026quot;Identive CLOUD 2700 R Smart Card Reader 0\u0026quot;); // Prepare a SamSelector that identifies the Calypso SAM SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.AUTO).build(); // Perform the SAM selection CardSelection samSelection = new CardSelection(); samSelection.prepareSelection(new SamSelectionRequest(samSelector)); if (!samReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;No SAM is present in the reader \u0026quot; + samReader.getName()); } SelectionsResult selectionsResult = samSelection.processExplicitSelection(samReader); if (!selectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;SAM matching failed!\u0026quot;); } CalypsoSam calypsoSam = (CalypsoSam) selectionsResult.getActiveSmartCard(); // Associate the calypsoSam and the samReader to create a samResource CardResource\u0026lt;CalypsoSam\u0026gt; samResource = new CardResource\u0026lt;\u0026gt;(samReader, calypsoSam); // Prepare a Calypso PO selection final String AID = \u0026quot;315449432E49434131\u0026quot;; /* AID: Keyple test kit profile 1, Application 2 */ final byte RECORD_NUMBER_1 = 1; final byte SFI_Environment = (byte) 0x07; CardSelection seSelection = new CardSelection(); // Setting up a selection based on the AID of a Calypso Revision 3.1 PO // // Select the first application matching the selection AID whatever the card communication protocol PoSelectionRequest poSelectionRequest = new PoSelectionRequest( PoSelector.builder() .aidSelector(CardSelector.AidSelector.builder().aidToSelect(AID).build()) // the application identifier .invalidatedPo(PoSelector.InvalidatedPo.REJECT) // to indicate if an invalidated PO should be accepted or not .build()); // Add the selection case to the current selection // (we could have added other cases) seSelection.prepareSelection(poSelectionRequest); if (!poReader.isCardPresent()) { throw new IllegalStateException(\u0026quot;The selection of the PO has failed.\u0026quot;); } // Perform the PO selection and get a CalypoPo container in return CalypsoPo calypsoPo = (CalypsoPo) seSelection.processExplicitSelection(poReader).getActiveSmartCard(); // Prepare the security settings used during the Calypso transaction PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource).build(); // Create a PoTransaction service to manage the Calypso transaction PoTransaction poTransaction = new PoTransaction( new CardResource\u0026lt;\u0026gt;(poReader, calypsoPo), poSecuritySettings); // Schedule the reading of the Environment file after the secure session is opened // (we could have added other commands) poTransaction.prepareReadRecordFile( SFI_Environment, // the sfi to select RECORD_NUMBER_1); // Perform the session opening with the debit key poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the Environment data from the card image CalypsoPo ElementaryFile efEnvironment = calypsoPo.getFileBySfi(SFI_Environment); String environmentLog = ByteArrayUtil.toHex(efEnvironment.getData().getContent()); System.out.println(\u0026quot;Environment file content: \u0026quot;+ environmentLog); // Schedule the closure of the channel with the PO after the closing of the secure session poTransaction.prepareReleasePoChannel(); // Perform the closing of the Calypso Secure Session poTransaction.processClosing(); System.out.println(\u0026quot;The data read in session have been certified by the successful closing.\u0026quot;); // Shutdown the application smartCardService.unregisterPlugin(plugin.getName()); System.exit(0); } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608122707,"objectID":"5bd0483d67597ee2c1518594e887fa73","permalink":"/keyple-website/docs/build-your-first-app/java-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/build-your-first-app/java-app/","section":"docs","summary":"This quick start describes how to create a ready-to-execute Java command-line application that runs a simple Calypso card-based transaction involving two readers.\n The demonstration application created for this quick start requires a Calypo card and a Calypo SAM.","tags":null,"title":"Build your first Java application","type":"book"},{"authors":null,"categories":null,"content":"Introduction Overview Since Keyple is supported by the Android operating system, developers can take advantage of this quick and easy way to implement solution to provide SmartCard communication functionalities in their own mobile application.\nFor example, Keyple could be used to facilitate the development of a ticketing application based on the use of conteners on a SIM card and relying on Android SE OMAPI. Keyple could also be used to develop an application reading SmartCard content through NFC using Android NFC.\n  As Keyple request low level reader access, the key features of Keyple SDK relies on components called \u0026lsquo;Plugins\u0026rsquo;. These are the plugins that allow access to the hardware functionality of the terminal by using the native Android SDK or the terminal manufacturer\u0026rsquo;s own custom SDKs.\nThis guide will describe how to start a ticketing application using Keyple SDK and Android NFC plugin to read the content of a Calypso SmartCard. As we want to focus on Keyple integration, the Android application architecture will remain the simplest as possible.\nWhat to we need for this guide?  Retail Device with NFC powered by android.nfc library (integrated into standard Android SDK). Android OS 19+ A NFC SmartCard with Calypso PO  Integration Application setup Like for any other Android NFC Application, we need to declare items in the application manifest.\n\u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\u0026gt; ... \u0026lt;uses-permission android:name=\u0026quot;android.permission.NFC\u0026quot; /\u0026gt; \u0026lt;uses-feature android:name=\u0026quot;android.hardware.nfc\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; ... \u0026lt;/manifest\u0026gt;  SDK Integration Keyple Core This high-level API is convenient for developers implementing smart card processing application for terminal interfaced with smart card readers. Access to the readers is provided by the plugins.\nTo use Keyple core API (and in fact, anything keyple\u0026rsquo;s related) import the jar within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-java-core:$keyple_version\u0026quot;  Please refer to Architecture/Keyle Core\nKeyple Plugins There are many Keyple plugins available, the one to use depends on the device and ticketing tools you are aiming to use.\nTo use the NFC plugin simply import it within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-android-nfc:$keyple_version\u0026quot;  Keyple Calypso The Keyple Calypso User API is an extension of the Keyple Core User API to manage Calypso Portable Objects.\nPlease refer to Architecture/Keyle Calypso\nTo use Keyple Calypso User API simply import the jar within the gradle dependencies of your Android application.\nimplementation \u0026quot;org.eclipse.keyple:keyple-java-calypso:$keyple_version\u0026quot;  Let\u0026rsquo;s code Initializing the SDK Register a plugin In order to setup Keyple, we need to register at least one plugin. Here we register our NFC plugin. To do so, we use the singleton SmartCardService and the plugin Factory. (See plugin development guide to know more about plugins)\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) /* register Android NFC Plugin to the SmartCardService */ try { val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -\u0026gt;} SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler)) }catch (e: KeypleException){ /* do something with it */ } }  Note: Plugins Factory\u0026rsquo;s initialisation could request more steps to execute before passing it to registerPlugin(). It depends on plugins, please check the documentation or usage example of desired plugin.\nUnregister a plugin Clean resources.\noverride fun onDestroy() { ... /* Unregister Android NFC Plugin to the SmartCardService */ SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME) reader = null super.onDestroy() }  Retrieve a specific reader With the plugin registered we can retrieve all instances of the component mapping the SmartCard readers. Here we want to retrieve the NFC reader.\n//We keep a reference to the reader for later use private lateinit var reader: AndroidNfcReader ... //PLUGIN_NAME and READER_NAME are constants provided by the used Keyple plugin reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader  Add observer to handle NFC events When native NFC is activated on an Android device, the OS dispatches insertion events occurring in the NFC detection field. In our application, we need detect it in order to proceed to exchanges with the SmartCard.\n//To keep it simple we choose to have our MainActivity implementing ObservableReader.ReaderObserver //interface. class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { ... reader.addObserver(this) ... //Belongs to ObservableReader.ReaderObserver //NFC Reader events will be received here. //this method is not triggered in UI thread override fun update(event: ReaderEvent) { if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){ //We'll select PO when SmartCard is presented in field //Method handlePo is described below handlePo() } } }  Activate a protocol Before starting to read a NFC tag, you must activate the protocol in which you wish to detect it. If you do not activate any protocol, no card will be detected by the Keyple library.\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ... // with this protocol settings we activate the nfc for ISO1443_4 protocol reader.activateProtocol( ContactlessCardCommonProtocols.ISO_14443_4.name, AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name) ) ... } }  Deactivate a protocol When your are done with your NFC operations, you can deactivate the NFC protocol :\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onDestroy() { ... //Deactivate nfc for ISO1443_4 protocol reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) ... super.onDestroy() } }  Now we have an access to our NFC Reader, we can activate Card Detection.\nActivate Card detection We will start detection as soon as our application comes in foreground and stop when application go background.\nclass MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onResume() { super.onResume() reader?.let { //We choose to continue waiting for a new card persentation it.startCardDetection(ObservableReader.PollingMode.REPEATING) } } }  Deactivate Card detection class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { override fun onPause() { reader?.let { it.stopCardDetection() } super.onPause() } }  Now we can detect when a SmartCard is presented in the field, we can proceed to card application selection and data reading.\nHandling a Calypso PO Calypso Selection API With Keyple, PO selection and FCI retrieving can be done using only Keyple Core, but Keyple Calypso API provides specific tools to handle Calypso POs and make the process a bit more simple.\nfun handlePo(){ reader?.let { //check if card is in the NFC field if(it.isCardPresent){ //Instanciate class handling card selection service val cardSelectionService = CardSelectionsService() //We only want to select the PO so we choose to close communication channel once //selection is done cardSelectionService.prepareReleaseChannel() //We build a selection request managing specific characteristics of Calypso POs val poSelection = PoSelection( PoSelector .builder() //Smarcard standard protocol .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) .aidSelector( CardSelector.AidSelector.builder() .aidToSelect(YOUR_AID) //Set the AID of your Calypso PO //indicates how to carry out the file occurrence in accordance with //ISO7816-4 .fileOccurrence(CardSelector.AidSelector.FileOccurrence.FIRST) //indicates which template is expected in accordance with ISO7816-4 .fileControlInformation( CardSelector.AidSelector.FileControlInformation.FCI) .build() ).build()) cardSelectionService.prepareSelection(poSelection) //Proceed to selection using the reader val selectionResult = cardSelectionService.processExplicitSelections(it) runOnUiThread { //We check the selection result and read the FCI if(selectionResult.hasActiveSelection()){ val matchedSmartCard = selectionResult.activeSmartCard val fci = matchedSmartCard.fciBytes Toast.makeText(this, String.format(\u0026quot;Selected, Fci %s\u0026quot;, ByteArrayUtil.toHex(fci)), Toast.LENGTH_LONG).show() }else { Toast.makeText(this, String.format(\u0026quot;Not selected\u0026quot;), Toast.LENGTH_SHORT).show() } } } } }  Now we\u0026rsquo;ve seen we can select our PO we can retrieve more data from it.\nReading Environment and usage In the below example we\u0026rsquo;ll read Environment and Usage data of an Hoplink container.\n... //Data related to Hoplink val poAid= \u0026quot;A000000291A000000191\u0026quot; val sfiHoplinkEFEnvironment = 0x14.toByte() val sfiHoplinkEFUsage = 0x1A.toByte() ... private fun handlePo(){ ... //Prepare the reading order. We'll read the first record of the EF //specified by its SFI. This reading will be done within explicit selection. poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1) poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1) ... //Hoplink is a Calypso PO, we can cast the SmartCard //with CalypsoPo class, representing the PO content. val calypsoPO = selectionResult.activeSmartCard as CalypsoPo val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment) val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage) Toast.makeText(this, String.format(\u0026quot;Environment %s\u0026quot;, ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show() Toast.makeText(this, String.format(\u0026quot;Usage %s\u0026quot;, ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show() }  Full code \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; package=\u0026quot;org.eclipse.keyple.android.quickstart\u0026quot;\u0026gt; \u0026lt;uses-permission android:name=\u0026quot;android.permission.NFC\u0026quot; /\u0026gt; \u0026lt;uses-feature android:name=\u0026quot;android.hardware.nfc\u0026quot; android:required=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;application android:allowBackup=\u0026quot;true\u0026quot; android:screenOrientation=\u0026quot;portrait\u0026quot; android:icon=\u0026quot;@mipmap/ic_launcher\u0026quot; android:label=\u0026quot;@string/app_name\u0026quot; android:roundIcon=\u0026quot;@mipmap/ic_launcher_round\u0026quot; android:supportsRtl=\u0026quot;true\u0026quot; android:theme=\u0026quot;@style/AppTheme\u0026quot;\u0026gt; \u0026lt;activity android:name=\u0026quot;.MainActivity\u0026quot;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt;  class MainActivity : AppCompatActivity(), ObservableReader.ReaderObserver { private var reader: AndroidNfcReader? = null val poAid= \u0026quot;A000000291A000000191\u0026quot; val sfiHoplinkEFEnvironment = 0x14.toByte() val sfiHoplinkEFUsage = 0x1A.toByte() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) try { val readerObservationExceptionHandler = ReaderObservationExceptionHandler { pluginName, readerName, e -\u0026gt;} val plugin = SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory(this, readerObservationExceptionHandler)) val reader = plugin.readers[AndroidNfcReader.READER_NAME] as AndroidNfcReader reader.addObserver(this) reader.activateProtocol( ContactlessCardCommonProtocols.ISO_14443_4.name, AndroidNfcProtocolSettings.getSetting(ContactlessCardCommonProtocols.ISO_14443_4.name) ) this.reader = reader }catch (e: KeypleException){ Timber.e(e) Toast.makeText(this, String.format(\u0026quot;Error: %s\u0026quot;, e.message), Toast.LENGTH_LONG).show() } } override fun onResume() { super.onResume() reader?.let { it.startCardDetection(ObservableReader.PollingMode.SINGLESHOT) Toast.makeText(this, String.format(\u0026quot;Hunt enabled\u0026quot;), Toast.LENGTH_SHORT).show() } } override fun onPause() { reader?.let { it.stopCardDetection() } super.onPause() } override fun onDestroy() { /* Deactivate nfc for ISO1443_4 protocol */ reader?.deactivateProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) /* Unregister Android NFC Plugin to the SmartCardService */ SmartCardService.getInstance().unregisterPlugin(AndroidNfcPlugin.PLUGIN_NAME) reader = null super.onDestroy() } override fun update(event: ReaderEvent) { Timber.d(\u0026quot;Event: %s\u0026quot;, event.eventType.name) runOnUiThread { Toast.makeText(this, String.format(\u0026quot;Event: %s\u0026quot;, event.eventType.name), Toast.LENGTH_SHORT).show() } if(event.eventType == ReaderEvent.EventType.CARD_INSERTED){ handlePo() } } //With Calypso API private fun handlePo(){ reader?.let { if(it.isCardPresent){ val cardSelectionService = CardSelectionService() cardSelectionService.prepareReleaseChannel() val poSelection = PoSelection( PoSelector .builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name) .aidSelector( CardSelector.AidSelector.builder() .aidToSelect(poAid) .fileOccurrence( CardSelector.AidSelector.FileOccurrence.FIRST) .fileControlInformation( CardSelector.AidSelector.FileControlInformation.FCI) .build() ).build()) cardSelectionService.prepareSelection(poSelection) //Prepare the reading order. We'll read the first record of the EF //specified by his SFI. This reading will be done with selection. poSelection.prepareReadRecordFile(sfiHoplinkEFEnvironment, 1) poSelection.prepareReadRecordFile(sfiHoplinkEFUsage, 1) //Selection and file reading will be done here val selectionResult = cardSelectionService.processExplicitSelections(it) runOnUiThread { if(selectionResult.hasActiveSelection()){ val matchedSmartCard = selectionResult.activeSmartCard val fci = matchedSmartCard.fciBytes Toast.makeText(this, String.format(\u0026quot;Selected, Fci %s\u0026quot;, ByteArrayUtil.toHex(fci)), Toast.LENGTH_SHORT).show() //Hoplink is a Calypso PO, we can cast the SmartCard //with CalypsoPo class, representing the PO content. val calypsoPO = selectionResult.activeSmartCard as CalypsoPo val environment = calypsoPO.getFileBySfi(sfiHoplinkEFEnvironment) val usage = calypsoPO.getFileBySfi(sfiHoplinkEFUsage) Toast.makeText(this, String.format(\u0026quot;Environment %s\u0026quot;, ByteArrayUtil.toHex(environment.data.content)), Toast.LENGTH_SHORT).show() Toast.makeText(this, String.format(\u0026quot;Usage %s\u0026quot;, ByteArrayUtil.toHex(usage.data.content)), Toast.LENGTH_SHORT).show() }else { Toast.makeText(this, String.format(\u0026quot;Not selected\u0026quot;), Toast.LENGTH_SHORT).show() } } } } } }  FAQ How to fix \u0026ldquo;More than one file was found with OS independent path \u0026lsquo;META-INF/NOTICE.md\u0026rsquo;.\u0026quot;\nAdd lines below to your :app build.gradle file\nandroid{ packagingOptions { exclude 'META-INF/NOTICE.md' } }  Where can I see more examples\nAndroid native plugins are provided with example applications. Check it to see more use cases: Examples\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607614011,"objectID":"b6315568584530a51ab9270955bdf885","permalink":"/keyple-website/docs/build-your-first-app/android-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/build-your-first-app/android-app/","section":"docs","summary":"Introduction Overview Since Keyple is supported by the Android operating system, developers can take advantage of this quick and easy way to implement solution to provide SmartCard communication functionalities in their own mobile application.","tags":null,"title":"Build your first Android application","type":"book"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607614011,"objectID":"423beac803544c19839507be44d3ef24","permalink":"/keyple-website/docs/build-your-first-app/cpp-app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/build-your-first-app/cpp-app/","section":"docs","summary":"","tags":null,"title":"Build your first C++ application","type":"book"},{"authors":null,"categories":null,"content":"This page describes the core elements of Keyple, i.e. the concepts and APIs of Keyple Core that are used to build any application implementing Keyple.\nIt is essential for the future user of Keyple to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on Keyple Core.\nReader Keyple\u0026rsquo;s primary goal being to interact with smart cards (or smartphones) worn by individuals, it is logical to put the Reader at the top of Keyple Core\u0026rsquo;s concepts.\nIndeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via Keyple Core or using an extension (such as Keyple Calypso).\nThese interfaces provide the means to\n identify the underlying physical reader, manage communication protocols, detect the presence and communicate with smart cards.  The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.\n[link to the detailed description of the reader related classes]\nPlugin In Keyple language a plugin is a service that allows the management of readers of a certain type. The plugin is responsible for informing the application about the availability of readers. The readers of the same plugin are usually hardware linked to the same physical interface.\nDepending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).\nThe Plugin interface essentially allows to list and retrieve the available readers.\n[link to the detailed description of the plugin related classes]\nSmart card service This is the Keyple Core service that concentrates the knowledge of active plugins and readers.\nAt startup, a Keyple application must register the plugins it uses. Conversely, it can also unregister them.\nThe SmartCardService will then make sure that the resources used are properly released.\n[link to the detailed description of the reader related classes]\nObservation The observation concept applies to readers as well as to plugins; optional, it is used depending on the needs.\nIt consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.\nNot all plugins and readers are observable.\nSelection In Keyple the concept of selection is derived from the application selection defined by the ISO7816-4 standard.\nIt supplements it by managing cards that do not have the standard command using identification mechanisms based on Answer To Reset and the communication protocol, and also by allowing the execution of commands immediately following application selection or detection.\nThis principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.\nSeveral targets can be defined by the application according to the different customer cards expected.\nThe default selection principle consists in providing an observable reader with a set of selection cases corresponding to the expected cards and receiving notifications containing not only the card identification but also the result of all additional commands that the application will have attached.\nAbstract smart card The abstract smart card concept is used by specific extensions (e.g. Keyple Calypso) and by the Keyple Core selection mechanism. It corresponds to an abstract container model implemented by the extension specific to a card type and returned by the selection process.\nThis container will be able to carry all the useful information known about the card.\nNote: this concept, mentioned here for understanding, should not appear to the application developer if he uses a card extension.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607714088,"objectID":"75da7a7b55da55c41fc1cb8fc8f8d35b","permalink":"/keyple-website/docs/developer-guide/common-concepts/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/common-concepts/","section":"docs","summary":"This page describes the core elements of Keyple, i.e. the concepts and APIs of Keyple Core that are used to build any application implementing Keyple.\nIt is essential for the future user of Keyple to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on Keyple Core.","tags":null,"title":"Common concepts","type":"book"},{"authors":null,"categories":null,"content":" Overview A centralized application is an application that runs in a device in contact with the end user.\nIt has at least one local smart card reader and manages itself the interaction with the user.\nIn the ticketing industry, it is typically the software that runs a validator, a vending machine or a control terminal.\nThe diagram below illustrates the organization of the local centralized components:   Before you start  In pre-requisite, read the common concepts page and become familiar with the basic concepts on which Keyple is based. Any implementation of a Keyple application starts with the implementation of Keyple Core, please study the workflow proposed in the following chapter. Explore the Keyple Core API to discover all the possibilities offered by Keyple Core. Take inspiration from the examples. Follow the explanations given in the Build your first app section to configure your environment. Using the Java components or C++ components pages, import Keyple Core into your project and start playing with Keyple. Don\u0026rsquo;t forget to explore the potential of Keyple card-specific extensions such as Keyple Calypso.  Workflow Keyple Core is built around the concepts described here and sometimes proposes several ways to perform an action or to achieve a result depending on the needs of the application.\nThe purpose of this section is to guide you in its use.\nCreation of the Smart Card Service This is the very first step in the realization of a Keyple application:\n/* Get the instance of the SmartCardService */ SmartCardService smartCardService = SmartCardService.getInstance();  The Smart Card Service is based on the SmartCardService object, which is a singleton that must be held by the application all along its execution.\nIts main role is to centralize Keyple resources and manage their lifecycle.\nChoose the plugin The Keyple application developer will choose the plugins he needs according to the equipment on which his Keyple application will run.\nFor example, if the environment is PC based, one will probably, but without obligation, go for the PC/SC plugin.\nFor an Andoid terminal environment, the plugin could be the standard Android NFC plugin or one of the plugins available from the industrial partners of the project. For a complete list of available plugins, please see the Java or C++ pages.\n A new plugin can also be created if the envisaged hardware does not yet have its plugin.   Register the plugin All Keyple plugins implement the Plugin interface.\nThe plugin registration consists in submitting its factory to the Smart Card Service.\n/* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, readerExceptionHandlerImpl));   The plugin factories all implement the interface expected by SmartCardService.\nDepending on the case, the constructor of the factory provided by the plugin can take parameters as argument.\nFor example, in the code above, the PC/SC plugin expects exception handlers, but in other cases it could be other parameters.\n  Observation of the plugin  The notion of plugin observation applies only to hardware environments in which the readers are removable.   The observation of reader connections and disconnections is achieved through a background task managed by Keyple Core.\nIt is therefore imperative to provide an exception handler to allow Keyple Core to warn the application in case of an execution error during monitoring or event notification.\nHere is an example of exception handler implementation in a PC/SC plugin context:\n... private static class PluginExceptionHandlerImpl implements PluginObservationExceptionHandler { @Override public void onPluginObservationError(String pluginName, Throwable throwable) { logger.error(\u0026quot;An unexpected plugin error occurred: {}\u0026quot;, pluginName, throwable); } } } /* Create an exception handler for plugin observation */ PluginExceptionHandlerImpl pluginExceptionHandlerImpl = new ExceptionHandlerImpl(); /* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, null)); ...  For the observation of the plugin itself, the application must provide an object implementing the PluginObserver interface to the plugin after having casted it in ObservablePlugin.\n((ObservablePlugin) plugin).addObserver(new PluginObserver());  The PluginObserver interface requires the implementation of the update method that will be called by Keyple Core when notifying plugin events.\nclass PluginObserver implements ObservablePlugin.PluginObserver { @Override public void update(PluginEvent event) { switch (event.getEventType()) { case READER_CONNECTED: // here the processing to be done when a reader is connected ... break; case READER_DISCONNECTED: // here the processing to be done when a reader is disconnected ... break; default: break; } } } }  Retrieve the reader Readers are objects implementing the Reader interface and are returned by the plugin\u0026rsquo;s getReader method taking the name of the reader as argument.\nThe names of the readers available from the plugin are returned as a list of strings by the getReaderNames method.\nThe getReaders method also allows to retrieve all readers in a Map whose key is the name of the reader and the value the Reader object.\nHere is an example to get the 1st PC/SC reader:\nString readerName = plugin.getReaderNames().get(0); Reader reader = plugin.getReader(readerName);   Depending on the type of plugin, the reader names are more or less dynamic (e.g. a PC/SC based system vs. an embedded terminal), it is sometimes necessary to implement an identification mechanism in order to assign the right reader to the right place in the system (for example by using regular expressions).   Customize the reader settings Take a close look at the parameters proposed by the plugin and its readers.\nIn particular, it is necessary to configure the expected communication protocols, but it is also possible that other settings exist depending on the hardware context.\nObservation of the reader The observation of inserting and removing cards from readers is similar to the observation of plugins in that it requires the same operations, i.e. the use of an exception handler and an object implementing a dedicated interface.\n... private static class ReaderExceptionHandlerImpl implements ReaderObservationExceptionHandler { @Override public void onReaderObservationError(String pluginName, String readerName, Throwable throwable) { logger.error(\u0026quot;An unexpected reader error occurred: {}:{}\u0026quot;, pluginName, readerName, throwable); } } } /* Create an exception handler for reader observation */ ReaderExceptionHandlerImpl readerExceptionHandlerImpl = new ExceptionHandlerImpl(); /* Assign the PcscPlugin to the SmartCardService */ plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, readerExceptionHandlerImpl)); ...  The observation of the events of the reader is done in a similar way to that of the plugin, by adding an observer:\n((ObservableReader) reader).addObserver(new ReaderObserver());  and implementing the ReaderObserver interface:\nclass ReaderObserver implements ObservableReader.ReaderObserver { @Override public void update(ReaderEvent event) { switch (event.getEventType()) { case CARD_INSERTED: // here the processing to be done when a card is inserted ... break; case CARD_MATCHED: // here the processing to be done when a card matched the selection ... break; case CARD_REMOVED: // here the processing to be done when a card is removed ... break; default: break; } } } }   Observation of the readers is optional in Keyple. It facilitates an event-driven programming mode, but an application developer can choose not to observe a reader, either because this reader is not designed to manage card insertions/withdrawals (for example an Android OMAPI reader or a SAM reader), or because the application is designed to directly manage the presence of a card (refer to the Reader interface).   Card selection The card selection service offered by Keyple Core gives multiple possibilities to choose the processing according to the type of card presented to the reader.\nIt is based on a filtering process according to three possible criteria, each of which is optional:\n the communication protocol of the card (usually also identifying a card technology) the answer to reset of the card (ATR) the ISO standardized application identifier (AID)  Each of these criteria can be defined in a CardSelector object.\nWhen a card is inserted, it is evaluated according to these criteria and will be given the status \u0026ldquo;selected\u0026rdquo; or not.\nWhen a card is not selected, no other operation will be possible with it. Depending on the chosen setting, the result of the selection will or will not be made available to the application. It is thus possible to directly ignore cards that do not correspond to the defined selection criteria.\nWhen a card is selected, the result is an object that extends the AbstractSmartCard and contains all the information known about the card at that stage.\nIn the case of a ISO standardized card, the application is selected with the provided AID (additional settings are available to specify the desired navigation within the card applications list).\nIn addition to the selection process itself, specific APDU commands can be sent to the card if the selection is successful. The output data of these commands are available in the instance of the object AbstractSmarCard.\nThe CardSelector and the additional APDU commands are grouped in a CardSelectionRequest object.\nOne or more CardSelectionRequest can be set up to perform as many selection cases, each targeting a particular card or application.\nThe final selection process takes as input a list of CardSelectionRequest and gets in return a list of CardSelectionResponse.\nCard selection steps In this guide we will not show the addition of supplementary APDU commands. Please refer to the Calypso guide for an implementation example.\nCreate the card selection service The card selection service will be used all along the card search process.\ncardSelectionService = new CardSelectionsService();  Create the selection cases The application can create as many selection cases as the type of cards expected. The order in which the selection cases are prepared is important because it will favor the latency delay for the processing of the cards corresponding to the first case. It is therefore recommended to place the most common card profile in the application context first.\n/** Create a new class extending AbstractCardSelection */ public final class GenericCardSelection extends AbstractCardSelection { public GenericCardSelection(CardSelector cardSelector) { super(cardSelector); } @Override protected AbstractSmartCard parse(CardSelectionResponse cardSelectionResponse) { class GenericSmartCard extends AbstractSmartCard { public GenericSmartCard(CardSelectionResponse cardSelectionResponse) { super(cardSelectionResponse); } public String toJson() { return \u0026quot;{}\u0026quot;; } } return new GenericSmartCard(cardSelectionResponse); } } final String aid1 = \u0026quot;AABBCCDDEE\u0026quot;; final String aid2 = \u0026quot;EEDDCCBBAA\u0026quot;; // first selection case targeting cards with AID1 GenericCardSelection cardSelector1 = new GenericCardSelection( CardSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid1).build()) .build()); // Add the selection case to the current selection cardSelectionsService.prepareSelection(cardSelector1); // first selection case targeting cards with AID1 GenericCardSelection cardSelector2 = new GenericCardSelection( CardSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid2).build()) .build()); // Add the selection case to the current selection cardSelectionsService.prepareSelection(cardSelector2);  Proceed to the selection with a non-observable reader The processExplicitSelections method of CardSelectionService performs the actual communication with the card.\n... // Check if a card is present in the reader if (!reader.isCardPresent()) { logger.error(\u0026quot;No Po Card is present in the reader.\u0026quot;); return; } // Actual card communication: operate through a single request the card selection CardSelectionsResult cardSelectionsResult = cardSelectionsService.processExplicitSelections(reader); ...  Proceed to the selection with an observable reader In the case of an observable reader, the selection request is provided to the reader (it is then named Default Selection) and will be processed automatically as soon as a card is presented. The application is then notified of the event with the data resulting from the selection. Depending on the selection settings, the application will be notified of all card presentations (CARD_INSERTED event) or only those presentations that led to a successful selection (CARD_MATCHED event).\nAdd a default selection // Provide the Reader with the selection operation to be processed when a card is inserted. ((ObservableReader) reader) .setDefaultSelectionRequest( cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(), ObservableReader.NotificationMode.MATCHED_ONLY, ObservableReader.PollingMode.REPEATING);  The NotificationMode allows you to specify whether all card insertions should be reported to the application or only those that led to a successful selection.\nPollingMode indicates whether to go back to waiting for the card after processing (REPEATING) or let the application decide when to restart the search (SINGLESHOT) with startCardDetection.\nNote: when the default selection is set with the PollingMode parameter, the card detection is started automatically. However, it is possible to set a default selection without automatic start and by starting the detection independently with startCardDetection.\nReceive the result as an event ... @Override public void update(ReaderEvent event) { switch (event.getEventType()) { case CARD_MATCHED: AbstractSmartCard selectedCard = null; try { selectedCard = getDefaultSelection() .processDefaultSelectionsResponse(event.getDefaultSelectionsResponse()) .getActiveSmartCard(); } catch (KeypleException e) { logger.error(\u0026quot;Exception: {}\u0026quot;, e.getMessage()); ((ObservableReader) (event.getReader())).finalizeCardProcessing(); } if (selectedCard != null) { logger.info(\u0026quot;Observer notification: the selection of the card has succeeded.\u0026quot;); // insert the processing of the card here ... logger.info(\u0026quot;= #### End of the card processing.\u0026quot;); } else { logger.error( \u0026quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.\u0026quot;); } break; case CARD_INSERTED: logger.error( \u0026quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.\u0026quot;); break; case CARD_REMOVED: logger.trace(\u0026quot;There is no PO inserted anymore. Return to the waiting state...\u0026quot;); break; default: break; } if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED || event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) { // Informs the underlying layer of the end of the card processing, in order to manage the // removal sequence. ((ObservableReader) (event.getReader())).finalizeCardProcessing(); } } ...  Get the selection result The result of the selection is available in the AbstractSmartCard object.\n... if (!cardSelectionsResult.hasActiveSelection()) { logger.warn(\u0026quot;The selection of the application \u0026quot; + cardAid + \u0026quot; failed.\u0026quot;); } AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard(); logger.info(\u0026quot;The selection of the card has succeeded.\u0026quot;); if (smartCard.hasFci()) { String fci = ByteArrayUtil.toHex(smartCard.getFciBytes()); logger.info(\u0026quot;Application FCI = {}\u0026quot;, fci); } if (smartCard.hasAtr()) { String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes()); logger.info(\u0026quot;Card ATR = {}\u0026quot;, atr); } ...  Implementation of the application service The applicative processing of the card that follows the selection of the card is to be inserted in the processing of the CARD_INSERTED or CARD_MATCHED event.\nIt can be processed in the thread provided by the monitoring task or detached in a separate thread. The application developer must pay attention to the handling of exceptions in this part of the application. Indeed, in case of a runtime exception, the information will be given to the application via the exception handler configured beforehand.\nStopping the application The clean shutdown of a Keyple application requires the release of resources and in particular the shutdown of the observation threads.\nThis is done by unregistering the plugins in the following way:\nsmartCardService.unregisterPlugin(plugin.getName());  Keyple Core API To learn all the details of the Keyple Core API, please consult the Javadoc documentation.\nHowever, here are two diagrams showing the main features of Keyple Core:\n  The diagram below represents the main classes implemented around the Smart Card Service with in particular the observation mechanisms.     The diagram below represents the main classes used for selection operations.     Examples To help in the implementation of the different facilities offered by Keyple to process smart cards, a set of examples is present in the project repository  examples\nNevertheless, you will find below a brief description of them:\nExplicit Selection Shows the use of Keyple to make a card selection without observing the reader, based on testing the presence of the card by the application.\n see the code\nDefault Selection Shows the use of Keyple to make a card selection with observation of the reader. A default selection is prepared, the presentation of a card triggers the notification of a reader event to the application.\n see the code\nSequential Multiple Selection Executes successively several independent selection operations with the use of the ISO \u0026lsquo;NEXT\u0026rsquo; navigation flag.\n see the code\nIllustrates the case of a card exploration avec maintient du canal physique ouvert.\nGrouped Multiple Selection Executes a multiple selection with logical channel closure between each selection.\nAllows the exploration of the applications of a card in a single operation but without selection at the end.\n see the code\nDemo Card Protocol Detection Demonstrates the use of Keyple in a context where several card technologies are likely to be processed by the application.\n see the code\nDemo Observable Reader Notification Demonstrates the use of Keyple to implement the observation of a plugin and its readers. Readers are dynamically created and an observer is assigned to them.\n see the code\nDownload The artifact Keyple Core and how to integrate it into your application is available here:\n  Keyple Core Java component  Keyple Core C++ component  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"c4b9318e7e497224c07c0ed508f52c3e","permalink":"/keyple-website/docs/developer-guide/centralized-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/centralized-application/","section":"docs","summary":"Overview A centralized application is an application that runs in a device in contact with the end user.\nIt has at least one local smart card reader and manages itself the interaction with the user.","tags":null,"title":"Centralized application","type":"book"},{"authors":null,"categories":null,"content":"Overview Keyple provides the \u0026ldquo;Keyple Distributed\u0026rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal.\nIn this way, you can manage transactions within a distributed architecture.\nThe diagram below shows the role of the Keyple Distributed components in the software layers used in a distributed architecture :\n  How to use it ?  In pre-requisite, read page Develop a Centralized Application to understand the main concepts of Keyple in a centralized application. Read chapter Concepts to understand the main terms and concepts of the Keyple Distributed solution. Read the introduction of chapter Remote Plugins to be informed about the different remote plugins and APIs proposed by the solution. Using chapter Use cases, find your use case. This will help you to determine exactly which library and API to use. Using chapter Download, import into your project the libraries specified by your use case. Using chapter Network configuration, implement the transport layer adapted to your network configuration. Implement your ticketing services as specified in the associated use case.  Concepts Here are the main concepts to keep in mind before continuing to read this developer guide :\n   Concept Description     Remote Lib This is the library keyple-plugin-remote-remote.\nIt must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.   Local Lib This is the library keyple-plugin-remote-local.\nIt must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.   Network Lib This is the library keyple-plugin-remote-network.\nThis library is implicitly imported by Remote Lib and Local Lib because it contains common network elements.   Remote Plugin Part of the Remote Lib, this is a Keyple plugin which provides only Remote Readers to the application. It manages data exchanges with the Local Service. This plugin must be registered to the smart card service like any Keyple plugin.   Remote Reader Part of the Remote Plugin, this is a Keyple reader which has some specificities :\n- each remote reader is connected to a local reader ;\n- any command sent by the application to a remote reader will be forwarded to the associated local reader ;\n- any event occurs on a local reader or plugin will be forwarded to the associated remote reader or plugin.   Local Service Part of the Local Lib, this service ensures data exchange between the Remote Plugin and local plugins and readers. It must be initialized and started by the host application.   Factory Remote Plugin and Local Service each have a specific factory class to initialize them.   Utility Remote Plugin and Local Service each have a specific utility class to access them everywhere in the code.   Node Remote Plugin and Local Service each are bind to a specific internal node which is responsible for the interfacing with the Network Endpoint.   Network Endpoint At the user\u0026rsquo;s charge, this component ensures the network exchanges between the Remote Plugin and Local Service nodes.      #concepts-table-1 table th:first-of-type { width: 130px; }  The diagram below illustrates the main functional concepts through a standard use case :\n  The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.\nThese could be for example a ticketing reloading service, where the intelligence would be on the terminal with remote readers, with thin clients on A \u0026amp; B terminals communicating locally with the cards.\nIn this use case, the Keyple Distributed solution is use for card communication.\n  Here is another example, but this time it illustrates several Remote Plugin components connected to the same Local Service.\nThese could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.\nIn this use case, the Keyple Distributed solution is use for SAM communication.\n  Remote Plugins The Keyple Distributed solution provides 3 different specific Remote Plugin components, each one having a specific API described in chapter Remote Plugins APIs designed on a Client-Server model in which the Client is always the initiator of the communication :\n   Plugin Description      RemotePluginServer Allows a server application to control a smart card reader available on a client (e.g. PO reader).    RemotePluginClient or\nObservableRemotePluginClient Allows a client application to control a smart card reader available on a server (e.g. SAM reader).    PoolRemotePluginClient Allows a client application to control a pool of smart cards readers available on a server (e.g. HSM readers).      #plugins-table-1 table th:first-of-type { width: 220px; }  Moreover, some plugins have different modes in which they allow or not the observation of plugin or reader events (such as smart card insertion, reader connection, etc\u0026hellip;).\nEach Remote Plugin and Local Service has a default name, but it\u0026rsquo;s possible to specify a custom name during the initialization phase.\nIt is thus possible to have within an application as many instances of a specific Remote Plugin or Local Service as desired.\nRemotePluginServer This plugin allows a server application to control a smart card reader available on a client (e.g. PO reader).\n   API Client Server     Library Local Lib Remote Lib   Remote Plugin / Local Service LocalServiceClient RemotePluginServer   Factory LocalServiceClientFactory RemotePluginServerFactory   Utility LocalServiceClientUtils RemotePluginServerUtils    USE AND SEQUENCE OF OPERATIONS  Server side :  configure the factory by providing the network and plugin observer implementation. Please note that this plugin is observable only to trigger ticketing services on the server side, but does not allow observation on the local plugin (reader insertion, etc\u0026hellip;), register the Remote Plugin to the smart card service using the factory, await for events of type PluginEvent.READER_CONNECTED, when an event occurs, get the specified remote reader from the Remote Plugin, use information inside the remote reader to identify the ticketing service to execute, execute the specified ticketing service using the remote reader and all of its others information, terminate the remote ticketing service using the Remote Plugin API by transmitting if needed personal information to the client.   Client side :  configure the factory and start the Local Service by providing the network implementation, register at least a local plugin to the smart card service and get the local reader to connect to the server, execute the remote service using the Local Service API by indicating the ticketing service id to execute and transmitting to the server if needed personal information or smart card content previously read.    ILLUSTRATION The following sequence diagram shows the capabilities of the plugin through an arbitrary example that illustrates :\n the initialization phase of the local and remote components ; the registration of the local plugin and observable reader ; the selection phase of an observable reader carried out directly by the client ; the sending of the selection result and additional information to the server to remotely perform a specific ticketing service (materialization, validation, etc\u0026hellip;) ; the reception by the server of the transmitted data ; the execution of the remote ticketing service ; the server subscription to observable reader events ; the sending of information to the client at the end of processing.  Note that the network layer is deliberately hide in this diagram. Its implementation is described in the Network configuration chapter.\n  RemotePluginClient This plugin allows a client application to control a smart card reader available on a server (e.g. SAM reader).\n   API Client Server     Library Remote Lib Local Lib   Remote Plugin / Local Service RemotePluginClient LocalServiceServer   Factory RemotePluginClientFactory LocalServiceServerFactory   Utility RemotePluginClientUtils LocalServiceServerUtils    USE AND SEQUENCE OF OPERATIONS  Server side :  configure the factory and start the Local Service by providing the network implementation, register at least a local plugin to the smart card service.   Client side :  configure the factory by providing the network implementation, register the Remote Plugin to the smart card service using the factory, use the Remote Plugin and its remote readers as a local plugin with local readers.    ObservableRemotePluginClient This plugin is a RemotePluginClient which also allows to observe the plugin events (such as reader connection, etc\u0026hellip;).\nPlease note that this mode is possible only if the local plugin is observable.\n   API Client Server     Library Remote Lib Local Lib   Remote Plugin / Local Service ObservableRemotePluginClient LocalServiceServer   Factory RemotePluginClientFactory LocalServiceServerFactory   Utility RemotePluginClientUtils LocalServiceServerUtils    USE AND SEQUENCE OF OPERATIONS  Server side :  configure the factory and start the Local Service by providing the network implementation, register at least a local plugin to the smart card service.   Client side :  configure the factory by providing the network implementation, register the Remote Plugin to the smart card service using the factory, use the Remote Plugin and its remote readers as a local observable plugin with local readers.    PoolRemotePluginClient This plugin allows a client application to control a pool of smart cards readers available on a server (e.g. HSM readers).\n   API Client Server     Library Remote Lib Local Lib   Remote Plugin / Local Service PoolRemotePluginClient PoolLocalServiceServer   Factory PoolRemotePluginClientFactory PoolLocalServiceServerFactory   Utility PoolRemotePluginClientUtils PoolLocalServiceServerUtils    USE AND SEQUENCE OF OPERATIONS  Server  configure the factory and start the Local Service by providing the network implementation, register at least a local pool plugin to the smart card service.   Client  configure the factory by providing the network implementation, register the Remote Plugin to the smart card service using the factory, use the Remote Plugin and its remote readers as a local pool plugin with local readers.    Remote Plugins APIs The class diagrams below shows the different APIs exposed and SPIs required by the Keyple Distributed solution.\nAn SPI (Service Provider Interface) is an interface that must be implemented by the user.\nHere are the available APIs depending on the library imported by your project :\n    Remote Lib Local Lib      Network API ✔️ ✔️    Remote Plugin API ✔️     Local Service API  ✔️    The associated API documentations are accessible from the page API Reference.\nNetwork API The associated API documentation is available here.\n  Remote Plugin API The associated API documentation is available here.\n  Local Service API The associated API documentation is available here.\n  Use cases Here is a summary table of all proposed use cases. Search for the one that corresponds to your need and then look at the associated description :\n   Use Case Reader type Reader endpoint Reader observation Plugin observation     UC 1 Simple Client     UC 2 Simple Client ✔️    UC 3 Simple Server     UC 4 Simple Server ✔️    UC 5 Simple Server  ✔️   UC 6 Simple Server ✔️ ✔️   UC 7 Pool Server        #use-cases-table-2 table th:nth-of-type(6) { width: 240px; }  UC 1 This use case requires to use the plugin RemotePluginServer.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the client side if needed.\n    Client Server     Methods to be used when initializing the factory withoutReaderObservation() -   Possible readers to use Reader or ObservableReader RemoteReaderServer    UC 2 This use case requires to use the plugin RemotePluginServer.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withReaderObservation(...) -   Possible readers to use ObservableReader ObservableRemoteReaderServer    To observe \u0026ldquo;remotely\u0026rdquo; the reader events, you must :\n Server  register at least one observer to the remote reader created during the first client call and await for reader events, retrieve the remote reader from the Remote Plugin imperatively using the reader name contained in the received event, execute the ticketing service associated to the event using the remote reader and all of its others information, terminate the remote ticketing service associated to the event using the Remote Plugin API by transmitting if needed personal information to the client.   Client  execute a remote service first in order to connect a remote reader to the local reader and to allow the remote application to subscribe to the events of the remote reader.    UC 3 This use case requires to use the plugin RemotePluginClient.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the server side if needed.\n    Client Server     Methods to be used when initializing the factory withoutPluginObservation()\nwithoutReaderObservation() -   Possible readers to use Reader Reader or ObservableReader    UC 4 This use case requires to use the plugin RemotePluginClient.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withoutPluginObservation()\nwithReaderObservation() -   Possible readers to use ObservableReader ObservableReader    UC 5 This use case requires to use the plugin ObservableRemotePluginClient.\nUse this mode if you don\u0026rsquo;t plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that it is still possible to observe locally the reader on the server side if needed.\n    Client Server     Methods to be used when initializing the factory withPluginObservation()\nwithoutReaderObservation() -   Possible readers to use Reader Reader or ObservableReader    UC 6 This use case requires to use the plugin ObservableRemotePluginClient.\nUse this mode if you plan to observe \u0026ldquo;remotely\u0026rdquo; the events related to the local reader (smart card insertion, removal, etc\u0026hellip;).\nPlease note that this mode is only possible if the local reader is observable.\n    Client Server     Methods to be used when initializing the factory withPluginObservation()\nwithReaderObservation() -   Possible readers to use ObservableReader ObservableReader    UC 7 This use case requires to use the plugin PoolRemotePluginClient.\nThis unique mode proposed for this plugin does not allow to observe the local reader.\n    Client Server     Methods to be used when initializing the factory - -   Possible readers to use Reader Reader    Network configuration The Keyple Distributed solution does not provide the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between Remote Plugin and Local Service components.\nSynchronous Choose this mode if you want to implement a Client-Server Synchronous communication protocol, such as standard HTTP for example.\n    Client Server     SPI to be implemented SyncEndpointClient -   Node API SyncNodeClient SyncNodeServer   Methods to be used when initializing the factory withSyncNode(...) withSyncNode()   Utility method to use to access the node - getSyncNode() or\ngetSyncNode(...)    Here is the minimal algorithm to implement in a context with a single server instance :\n  In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a serverNodeId are routed to the server associated with a SyncNodeServer node having the serverNodeId.\nAsynchronous Choose this mode if you want to implement a Full-Duplex Asynchronous communication protocol, such as Web Sockets for example.\n    Client Server     SPI to be implemented AsyncEndpointClient AsyncEndpointServer   Node API AsyncNodeClient AsyncNodeServer   Methods to be used when initializing the factory withAsyncNode(...) withAsyncNode(...)   Utility method to use to access the node getAsyncNode() or\ngetAsyncNode(...) getAsyncNode() or\ngetAsyncNode(...)    Here is the minimal algorithm to implement :\n  Exchanged data The data exchanged between Remote Plugin and Local Service components are contained in the DTO (Data Transfer Object) MessageDto. It is built and processed by the plugin and you don\u0026rsquo;t need to modify it.\nHowever, it is necessary in some contexts to access certain information such as the sessionId in the case of asynchronous communication or the serverNodeId in the case of synchronous communication with several server instances.\nExamples All examples are available here.\nDownload JARs All deliverables (JARs, changelogs, javadocs) are available on the Maven Central Repository.\nSo you can use Gradle or Maven to import the JARs into your project or download them directly from the Maven Central Repository.\nNote that it is strongly recommended to use the same version for Remote Lib and Local Lib.\nGRADLE  Remote Lib  implementation 'org.eclipse.keyple:keyple-plugin-remote-remote:1.0.0'   Local Lib  implementation 'org.eclipse.keyple:keyple-plugin-remote-local:1.0.0'  MAVEN  Remote Lib  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-remote-remote\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Local Lib  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-plugin-remote-local\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  MAVEN CENTRAL REPOSITORY  Network Lib Remote Lib Local Lib  Sources The sources are available on GitHub :\n  Network Lib  Remote Lib  Local Lib  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608113699,"objectID":"abf0869ed81b99ec70d4ecc72737c54d","permalink":"/keyple-website/docs/developer-guide/distributed-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/distributed-application/","section":"docs","summary":"Overview Keyple provides the \u0026ldquo;Keyple Distributed\u0026rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal.\nIn this way, you can manage transactions within a distributed architecture.","tags":null,"title":"Distributed application","type":"book"},{"authors":null,"categories":null,"content":"Overview Work in Progress\nKeyple API was designed to support an extension system. On top of Keyple Core, APIs can be developed to extend Keyple features. For example, Calypso Network Association provides Keyple Calypso Extension.\nThe use of Keyple Calypso Extension open the ability to operate commands with a calypso Portable Object and to manage a secure calypso transaction.\nThe diagram below shows the role of the Keyple Calypso Extension components in the software layers for a centralized application :\n  Before you start  In pre-requisite, have knowledge of the standard Calypso. Read the common concepts page and become familiar with the basic concepts on which Keyple is based. Any implementation of a Keyple application starts with the implementation of Keyple Core, please study the workflow proposed in Centralized application guide. Read chapter Concepts to understand the main terms and concepts of the Keyple Calypso Extension API. Explore the Keyple Calypso API to discover all the possibilities offered by Keyple Calypso Extension. Take inspiration from the examples. Follow the explanations given in the Build your first app section to configure your environment. Using the Java components or C++ components page, import Keyple Core and Keyple Calyspo Extension into your project and start playing with Keyple.  How to use it  In pre-requisite, read page Develop a Centralized Application to understand the main concepts of Keyple in a centralized application. Read chapter Concepts to understand the main terms and concepts of the Keyple Calypso Extension API.  Concepts Here are the main concepts to keep in mind before continuing to read this developer guide :\nCalypso PO Concentrate all known informations about the Personal Object being processed. Accessible informations are\n The application identification fields (revision/version, class, DF name, serial number, ATR, issuer) The indication of the presence of optional features (Stored Value, PIN, Rev3.2 mode, ratification management) The management information of the modification buffer The invalidation status The files, counters, SV data read or modified during the execution of the processes defined by PoTransaction  Calypso PO fields are populated from a CardSelectionResponse obtained through the process of a PO selection.\n... //Retrieve PO's informations String atr = calypsoPo.getAtr() byte[] applicationSerial+Number = calypsoPo.getApplicationSerialNumber() //SFI_EventLog = 0x08 ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog); //SFI_EnvironmentAndHolder = 0x07 ElementaryFile efEnvironmentAndHolder =calypsoPo.getFileBySfi(SFI_EnvironmentAndHolder); ...  ElementaryFile Object containing the description of a Calypso Elementary File. Can be retrieved from Calypso PO using its SFI.\n... ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog); //Read data content of sevent log elemenatary file String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent()); ...  PoSelection Service extending Keyple Core Abstract Card Selection to manage specific features of Calypso POs during the selection:\n Send APDU Commands to the POs right after the card selection. Produce a Calypso PO from the CardSelectionResponse. The object is filled with the PO identification data from the FCI and the possible responses to additional APDU commands executed after the selection.  ... // Prepare a Calypso PO selection CardSelectionsService cardSelectionsService = new CardSelectionsService(); // Setting of an AID based selection of a Calypso REV3 PO // Select the first application matching the selection AID whatever the card communication // protocol keep the logical channel open after the selection // Calypso selection: configures a PoSelection with all the desired attributes to // make the selection and read additional information afterwards PoSelection poSelection = new PoSelection( PoSelector.builder() .cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name()) .aidSelector( CardSelector.AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build()) .invalidatedPo(PoSelector.InvalidatedPo.REJECT) .build()); // Prepare the reading order. poSelection.prepareReadRecordFile( CalypsoClassicInfo.SFI_EnvironmentAndHolder, CalypsoClassicInfo.RECORD_NUMBER_1); // Add the selection case to the current selection (we could have added other cases // here) cardSelectionsService.prepareSelection(poSelection); CalypsoPo calypsoPo = (CalypsoPo) cardSelectionsService.processExplicitSelections(poReader).getActiveSmartCard(); ...  Calypso SAM Concentrates all the informations we know about the SAM currently selected. Accessible informations are:\n The Sam Revision The Serial number The Platform identifier The Application Type The Application SubType The Software Issuer identifier The Software Version number The Software Revision number  Calypso SAM fields are populated by analysis of the ATR within a CardSelectionResponse obtained through the process of a SAM selection.\n... byte[] serialNumber = calypsoSam.getSerialNumber() ...  SamSelection Service extending Keyple Core Abstract Card Selection specialized to manage the specific characteristics of Calypso SAMs. The service provides an instance of Calypso SAM and may execute the unlock command during the selection process.\n... CardSelectionsService samSelection = new CardSelectionsService(); //Sam selection parameters SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.C1).serialNumber(\u0026quot;.*\u0026quot;).build(); samSelection.prepareSelection(new SamSelection(samSelector)); //Sam reader retrieved from registered plugin CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader); if (!cardSelectionsResult.hasActiveSelection()) { throw new IllegalStateException(\u0026quot;Unable to open a logical channel for SAM!\u0026quot;); } //Cast selected card to CalypsoSam CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard(); ...  PoSecuritySettings Concentrate the security settings involved in Calypso Secure Sessions:\n A reference to the Sam resource The default KIF The default KVC The default Key Record Number The modification mode The ratification mode The pin transmission mode The default Pin Ciphering Key The SV Get Log Reade mode the SV Negative balance  The fields are populated with default values when the object is instantiated but can be customized to adjust the settings to the application needs.\n// Security settings // Both Reload and Debit SV logs are requested PoSecuritySettings poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .svGetLogReadMode(SvSettings.LogRead.ALL) .build();  SAM Resource Managers Services providing methods to allocate/deallocate SAM resources. Keyple Calypso API provides 3 type of managers: Default, Factory, Pool. The choice of the manager to use depends on the abilities of the plugin used for the SAM connexion.\nPoTransaction Service providing high-level API to manage transactions with a Calypso PO. The tied Calypso PO Object is kept and updated at each step of using this service.\nThis service workflow is composed of two steps:\n Prepare the commands to be executed to the PO Process the prepared commands. Regarding of commands, the presence of SAM could be mandatory.  ... CardResource\u0026lt;CalypsoPo\u0026gt; poResource = new CardResource\u0026lt;CalypsoPo\u0026gt;(poReader, calypsoPo); PoTransaction poTransaction = new PoTransaction(poResource, poSecuritySettings); // Read the EventLog file at the Session Opening poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_EventLog, CalypsoClassicInfo.RECORD_NUMBER_1); // Open a secure session (DEBIT level) and execute the prepared command poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT); // Get and display the EventLog data ElementaryFile efEventLog = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_EventLog); String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent()); logger.info(\u0026quot;File Event log: {}\u0026quot;, eventLog); // Prepare a SV Debit (this command could also have been placed before processOpening // since it is not followed by any other command) poTransaction.prepareSvGet(SvSettings.Operation.DEBIT, SvSettings.Action.DO); // Execute the prepared command poTransaction.processPoCommands(); //Get updated sv balance int svBalance = calypsoPo.getSvBalance() //Get the updated SV last transaction number int svLastTNum = calypsoPo.getSvLastTNum() ...  API Examples Detailed use case examples can be seen here: Example\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1608051927,"objectID":"ee4b94e5a1e3f91ea9d84ef8b81d32c1","permalink":"/keyple-website/docs/developer-guide/calypso-application/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/calypso-application/","section":"docs","summary":"Overview Work in Progress\nKeyple API was designed to support an extension system. On top of Keyple Core, APIs can be developed to extend Keyple features. For example, Calypso Network Association provides Keyple Calypso Extension.","tags":null,"title":"Calypso application","type":"book"},{"authors":null,"categories":null,"content":"Overview In order to provide an easy way to port a Keyple application from a device with a specific card reader to another, a plugin system as been developed. When a developer wants to include Keyple features within his project, he has to initialize the SmartCardService by providing a plugin Factory available with in the plugin library. The plugin to use depends on the targeted device and running environment.\nFor example, for an android device with native NFC we\u0026rsquo;ll use KeypleAndroidNfcPlugin.\nimplementation 'org.eclipse.keyple:keyple-android-plugin-nfc:$keyple_version'  [kotlin] SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory())  Keyple is already provided with various plug-ins ready to use. For example Android NFC or PC/SC reader plugins.\nBut users of the Keyple API may need to use it on new hardware not covered with existing plugins. In this case, a new one must be developed.\nThe purpose of this guide is to support developers in this process.\nExisting plugins    Name plateform Import     Keyple Android NFC Android OS with android.nfc implementation Maven central   Keyple Android OMAPI Android OS with android.se or Simalliance openmobileapi implementation Maven Central   Keyple Android Famoco Famoco\u0026rsquo;s Android device using lib-secommunication-1.7.0 for NFC Contact us   Keyple Android Coppernic Coppernic\u0026rsquo;s Android OS using ASK Contact us   Keyple Android Wizway Android OS with Wizway NFC Agent Contact us   Keyple Java PCSC Device running JVM with connected PC/SC reader Maven Central    Class diagram of plugin package For the record, this is a wide view of classes implied in the plugin system. It is designed to natively handle as much use cas as possible while being easy to use. It results of several internal classes, however, plugin\u0026rsquo;s developers will only have to use a few part of these elements.\n  Steps Plugin\u0026rsquo;s development relies on 3 main steps, each one consists in implementing a few set of abstract classes and interfaces of plugin package from Keyple Core API:\n Import Keyple dependency Implement a Keyple Reader Implement a Keyple Plugin Implement a Keyple Plugin Factory.  Imports Your plugin will use be based upon Keyple Core libraries:\nimplementation \u0026quot;org.eclipse.keyple:keyple-java-core:$keyple_version\u0026quot;  Implement Keyple Reader The first step of a Keyple plugin development is the implementation of Keyple Reader Interface (org.eclipse.keyple.core.Reader). This implementation should use device\u0026rsquo;s native smartcard reader library (or sdk package) to map interfaces used by Keyple API.\nThis implementation of a local reader must be done through the extension of one of three abstract classes provided within the Keyple API. The choice depends on expected behaviour of the reader:\n AbstractLocalReader: Basic abstract class to use for local reader implementation. AbstractObservableLocalReader: extends AbstractLocalReader and is used to manage the matter of observing card events in the case of a local reader (ie: card insertion, card removal..). AbstractObservableLocalAutonomousReader: extends AbstractObservableLocalReader and is used to allow the reader implementation to call back the core when card insertion and removal events occurs.    Once chosen, the Abstract class must be extended by the new reader class and abstract methods must be implemented. Please refer to your native reader documentation to implement this elements.\nImplementation of AbstractLocalReader\u0026rsquo;s abstract classes Relying on the native smartcard reader of the device, implementations to be done are:\n   Method to implement Description     boolean checkCardPresence() Verify the presence of the card   byte[] getATR() provides the information retrieved when powering up the card   openPhysicalChannel() Attempts to open the physical channel   closePhysicalChannel() Attempts to close the current physical channel   boolean isPhysicalChannelOpen() Tells if the physical channel is open or not   boolean isCurrentProtocol(String readerProtocolName) Tells if the current card communicates with the protocol provided as an argument   byte[] transmitApdu(byte[] apduIn) Transmits a single APDU and receives its response. Both are in the form of an array of bytes.   activateReaderProtocol(String readerProtocolName) Activates the protocol provided from the reader\u0026rsquo;s implementation point of view.   deactivateReaderProtocol(String readerProtocolName) Deactivates the protocol provided from the reader\u0026rsquo;s implementation point of view.   isContactless() Tells if the current card communication is contactless.      #plugins-table-1 table th:first-of-type { width: 450px; }  Example of implementations are provided here.\nImplementation of AbstractObservableLocalReader\u0026rsquo;s abstract classes In addition of AbstractLocalReader\u0026rsquo;s methods, specific implementations to be done are:\nMethods    Method to implement Description     void onStartDetection() Invoked when the card detection is started by the Keyple Plugin   void onStopDetection() Invoked when the card detection is stopped by the Keyple Plugin   ReaderObservationExceptionHandler getObservationExceptionHandler() Allows to invoke the defined handler when an exception condition needs to be transmitted to the application level    Beside the implementation of this methods, this observable reader\u0026rsquo;s notification behaviour must be set.\nObservable reader\u0026rsquo;s notification Observable reader\u0026rsquo;s notification behaviour is set up by implementing interfaces inheriting from ObservableReaderNotifiers. Developer has to choose how the reader should behave regarding its native abilities. It may involve a few more methods to implement.\n  It is mandatory to implement one, and only one, interface of each use case presented in the related columns in the below table.\n   Card Insertion Card Removal Card Processing     WaitForCardInsertionAutonomous WaitForCardRemovalAutonomous WaitForCardRemovalDuringProcessing   WaitForCardInsertionBlocking WaitForCardRemovalBlocking DontWaitForCardRemovalDuringProcessing   WaitForCardInsertionNonBlocking WaitForCardRemovalNonBlocking \u0026mdash;    Description of the Insertion/Removal behaviours:\n   Type Description     [*]Autonomous Interface to be implemented by readers that have a fully integrated management of card communications for card insertion/removal detection   [*]Blocking Interface to be implemented by readers that are autonomous in the management of waiting for the insertion/removal of a card and that provide a method to wait for it indefinitely.   [*]Non Blocking Interface to be implemented by readers that require an active process to detect the card insertion /removal.      #plugins-table-2 table th:first-of-type { width: 180px; }  Description of the processing behaviours:\n   Type Description     WaitForCardRemovalDuringProcessing Interface to be implemented by readers able to detect a card removal during processing, between two APDU commands.   DontWaitForCardRemovalDuringProcessing Interface to be implemented by readers not able to detect a card removal during processing, between two APDU commands.      #plugins-table-3 table th:first-of-type { width: 350px; }  Example of implementations are provided here.\nImplementation of AbstractObservableLocalAutonomousReader\u0026rsquo;s abstract classes In addition of AbstractObservableLocalReader\u0026rsquo;s methods and ObservableReaderNotifiers implementation, specific methods invocation must be done:\n   Method to invoke Description     void onCardInserted() This method must be invoked when a card is inserted to.   void onCardRemoved() This method must be invoked when a card is removed.    Example of implementations are provided here.\nImplement Keyple Plugin The next step of Keyple plugin development is the implementation of Keyple Plugin Interface (org.eclipse.keyple.core.service.Plugin). The plugin will provide access to the readers and handle their lifecycle.\nAs well as Reader\u0026rsquo;s implementation, abstract classes to extend and interfaces to implement will depend on native abilities of the device.\nThis implementation of a plugin must be done through the extension of one of three abstract classes provided within the Keyple API. The choice depends on expected behaviour of the plugin:\n AbstractPlugin: Basic class for plugin implementation. AbstractObservablePlugin: This class provides the means to observe a plugin(insertion/removal of readers). AbstractThreadedObservablePlugin: This class provides the means to observe a plugin(insertion/removal of readers) using a monitoring thread.    Implementation of AbstractPlugin\u0026rsquo;s abstract classes initNativeReaders()    Method to implement Description     ConcurrentMap\u0026lt;String, Reader\u0026gt; initNativeReaders() This method is invoked when registering a plugin. It should be implemented to init readers map.    Example of implementations are provided here.\nImplementation of AbstractObservablePlugin\u0026rsquo;s abstract classes There is no additional methods to implement compared to AbstractPlugin\nImplementation of AbstractThreadedObservablePlugin\u0026rsquo;s abstract classes In addition of AbstractObservablePlugin\u0026rsquo;s methods and ObservableReaderNotifiers implementation, specific methods invocations must be done:\n   Method to implement Description     SortedSet\u0026lt;String\u0026gt; fetchNativeReadersNames() This method Fetch the list of connected native reader (usually from third party library) and returns their names (or id)   Reader fetchNativeReader(String name) Fetch connected native reader (from third party library) by its name returns the current AbstractReader if it is already listed. Creates and returns a new AbstractReader if not.      #plugins-table-4 table th:first-of-type { width: 300px; }  Example of implementations are provided here.\nImplementation of AbstractPluginFactory\u0026rsquo;s abstract classes The last step is to implement the Plugin factory which is going to be use by Keyple core to handle the plugin.\n   Method to implement Description     String getPluginName() Retrieve the name of the plugin that will be instantiated by this factory (can be static or dynamic)   Plugin getPlugin() Retrieve an instance of a plugin (can be a singleton)      #plugins-table-5 table th:first-of-type { width: 220px; }  Example of implementations are provided here.\nExamples of implementation AbstractLocalReader checkCardPresence() Allow Keyple to check if the smartcard is present within the reader (inserted, in NFC field\u0026hellip;)\nOMAPI Example\n[kotlin] //nativeReader is an instance of android.se.omapi.Reader. It natively provides a method to check Card presence. override fun checkCardPresence(): Boolean { return nativeReader.isSecureElementPresent }  Android NFC Example\n[kotlin] //When a SE is presented in the NFC field, we can get a tagproxy object. When the SE is removed, //this value is reinited. So when it is not null, we can assume the SE is currently in the field. //The presence information is not directly available be we can find a way to implement checkCardPresence() public override fun checkCardPresence(): Boolean { return tagProxy != null }  PC/SC Example\n[java] public override fun checkCardPresence(): Boolean { //Terminal is an instance of CardTerminal provided by javax.smartcardio return terminal.isCardPresent(); }  getAtr() OMAPI Exemple\n[kotlin] override fun getATR(): ByteArray? { //Session is a native object of android.se.omapi package return session?.let { it.atr } }  Android NFC Example\n[kotlin] public override fun getATR(): ByteArray? { //TagProxy is an object mapping android.nfc.tech.TagTechnology. Atr is obtained from data of this object (depending of protocol) val atr = tagProxy?.atr return if (atr?.isNotEmpty() == true) atr else null }  PC/SC Example\n[java] public override fun checkCardPresence(): Boolean { //Card is an instance of card provided by javax.smartcardio return return card.getATR().getBytes();; }  openPhysicalChannel() OMAPI Exemple\n[kotlin] @Throws(KeypleReaderIOException::class) override fun openPhysicalChannel() { try { //nativeReader is an instance of import android.se.omapi.Reader session = nativeReader.openSession() } catch (e: IOException) { throw KeypleReaderIOException(\u0026quot;IOException while opening physical channel.\u0026quot;, e) } }  Android NFC Example\n[kotlin] @Throws(KeypleReaderIOException::class) public override fun openPhysicalChannel() { //TagProxy is a wrapper we created in the plugin //To handle android.nfc.Tag if (tagProxy?.isConnected != true) { try { tagProxy?.connect() } catch (e: IOException) { throw KeypleReaderIOException(\u0026quot;Error while opening physical channel\u0026quot;, e) } } }  PC/SC Example\n[java] public void openPhysicalChannel() { //card is an instance of Card provided by javax.smartcardio if (card == null) { this.card = this.terminal.connect(parameterCardProtocol); } else { logger.debug(\u0026quot;[{}] Opening of a card physical channel in shared mode.\u0026quot;, this.getName()); } } //CardChannel is an instance of card provided by javax.smartcardio this.channel = card.getBasicChannel(); }  closePhysicalChannel() OMAPI Exemple\n[kotlin] override fun closePhysicalChannel() { //openChannel is an instance of android.se.omapi.Channel openChannel?.let { it.session.close() openChannel = null } }  Android NFC Example\n[kotlin] @Throws(KeypleReaderIOException::class) public override fun closePhysicalChannel() { try { //TagProxy is a wrapper we created in the plugin //To handle android.nfc.Tag tagProxy?.close() } catch (e: IOException) { throw KeypleReaderIOException(\u0026quot;Error while closing physical channel\u0026quot;, e) } finally { tagProxy = null } }  PC/SC Example\n[java] protected void closePhysicalChannel() { try { //card is an instance of Card provided by javax.smartcardio if (card != null) { channel = null; card.disconnect(true); card = null; } } catch (CardException e) { throw new KeypleReaderIOException(\u0026quot;Error while closing physical channel\u0026quot;, e); } }  isPhysicalChannelOpen() OMAPI Exemple\n[kotlin] override fun isPhysicalChannelOpen(): Boolean { //Session is an instance of android.se.omapi.Session return session?.isClosed == false }  Android NFC Example\n[kotlin] public override fun isPhysicalChannelOpen(): Boolean { //TagProxy is a wrapper we created in the plugin //To handle android.nfc.Tag return tagProxy?.isConnected == true }  PC/SC Example\n[java] protected boolean isPhysicalChannelOpen() { return card != null; }  transmitApdu(byte[] apduIn) OMAPI Exemple\n[kotlin] override fun transmitApdu(apduIn: ByteArray): ByteArray { // Initialization Timber.d(\u0026quot;Data Length to be sent to tag : \u0026quot; + apduIn.size) Timber.d(\u0026quot;Data in : \u0026quot; + ByteArrayUtil.toHex(apduIn)) var dataOut = byteArrayOf(0) try { openChannel.let { dataOut = it?.transmit(apduIn) ?: throw IOException(\u0026quot;Channel is not open\u0026quot;) } } catch (e: IOException) { throw KeypleReaderIOException(\u0026quot;Error while transmitting APDU\u0026quot;, e) } Timber.d(\u0026quot;Data out : \u0026quot; + ByteArrayUtil.toHex(dataOut)) return dataOut }  Android NFC Example\n[kotlin] public override fun transmitApdu(apduIn: ByteArray): ByteArray { Timber.d(\u0026quot;Send data to card : ${apduIn.size} bytes\u0026quot;) return with(tagProxy) { if (this == null) { throw KeypleReaderIOException( \u0026quot;Error while transmitting APDU, invalid out data buffer\u0026quot;) } else { try { val bytes = transceive(apduIn) if (bytes.size \u0026lt;2) { throw KeypleReaderIOException( \u0026quot;Error while transmitting APDU, invalid out data buffer\u0026quot;) } else { Timber.d(\u0026quot;Receive data from card : ${ByteArrayUtil.toHex(bytes)}\u0026quot;) bytes } } catch (e: IOException) { throw KeypleReaderIOException( \u0026quot;Error while transmitting APDU, invalid out data buffer\u0026quot;, e) } catch (e: NoSuchElementException) { throw KeypleReaderIOException(\u0026quot;Error while transmitting APDU, no such Element\u0026quot;, e) } } } }  PC/SC Example\n[java] protected byte[] transmitApdu(byte[] apduIn) { ResponseAPDU apduResponseData; if (channel != null) { try { apduResponseData = channel.transmit(new CommandAPDU(apduIn)); } catch (CardException e) { throw new KeypleReaderIOException(this.getName() + \u0026quot;:\u0026quot; + e.getMessage()); } catch (IllegalArgumentException e) { // card could have been removed prematurely throw new KeypleReaderIOException(this.getName() + \u0026quot;:\u0026quot; + e.getMessage()); } } else { // could occur if the card was removed throw new KeypleReaderIOException(this.getName() + \u0026quot;: null channel.\u0026quot;); } return apduResponseData.getBytes(); }  activateReaderProtocol(String readerProtocolName) OMAPI Exemple\n[kotlin] override fun activateReaderProtocol(readerProtocolName: String?) { // do nothing as protocol ils not relevant for contact PO }  Android NFC Example\n[kotlin] override fun activateReaderProtocol(readerProtocolName: String?) { if (!protocolsMap.containsKey(readerProtocolName)) { //we map the requested protocol to a custom android protocol protocolsMap.put(readerProtocolName!!, AndroidNfcProtocolSettings.getSetting(readerProtocolName!!)!!) } }  PC/SC Example\n[java] protected void activateReaderProtocol(String readerProtocolName) { if (!PcscProtocolSetting.getSettings().containsKey(readerProtocolName)) { throw new KeypleReaderProtocolNotSupportedException(readerProtocolName); } }  deactivateReaderProtocol(String readerProtocolName) OMAPI Exemple\n[kotlin] override fun deactivateReaderProtocol(readerProtocolName: String?) { // do nothing }  Android NFC Example\n[kotlin] override fun deactivateReaderProtocol(readerProtocolName: String?) { if (protocolsMap.containsKey(readerProtocolName)) { protocolsMap.remove(readerProtocolName) } Timber.d(\u0026quot;${getName()}: Deactivate protocol $readerProtocolName.\u0026quot;) }  PC/SC Example\n[java] protected void deactivateReaderProtocol(String readerProtocolName) { if (!PcscProtocolSetting.getSettings().containsKey(readerProtocolName)) { throw new KeypleReaderProtocolNotSupportedException(readerProtocolName); } if (logger.isDebugEnabled()) { logger.debug(\u0026quot;{}: Deactivate protocol {}.\u0026quot;, getName(), readerProtocolName); } }  isCurrentProtocol(String readerProtocolName) OMAPI Exemple\n[kotlin] override fun isCurrentProtocol(readerProtocolName: String?): Boolean { return AndroidOmapiSupportedProtocols.ISO_7816_3.name == readerProtocolName }  Android NFC Example\n[kotlin] override fun isCurrentProtocol(readerProtocolName: String?): Boolean { return readerProtocolName == null || protocolsMap.containsKey(readerProtocolName) \u0026amp;\u0026amp; protocolsMap[readerProtocolName] == tagProxy?.tech }  PC/SC Example\n[java] protected boolean isCurrentProtocol(String readerProtocolName) { String protocolRule = PcscProtocolSetting.getSettings().get(readerProtocolName); String atr = ByteArrayUtil.toHex(card.getATR().getBytes()); return Pattern.compile(protocolRule).matcher(atr).matches(); }  isContactless() OMAPI Exemple\n[kotlin] override fun isContactless(): Boolean { //OMAPI is a contact Reader return false }  Android NFC Example\n[kotlin] override fun isContactless(): Boolean { //NFC is a contactless Reader return true }  PC/SC Example\n[java] public boolean isContactless() { //isContactless is a custom variable that can be set by the plugin //as PC/SC can be a contactless or contact reade. if (isContactless == null) { /* First time initialisation, the transmission mode has not yet been determined or fixed explicitly, let's ask the plugin to determine it (only once) */ isContactless = ((AbstractPcscPlugin) SmartCardService.getInstance().getPlugin(getPluginName())) .isContactless(getName()); } return isContactless; }  AbstractObservableLocalReader onStartDetection() Android NFC Example\n[kotlin] override fun onStartDetection() { // When Keyple Core starts detection, we have to use native Android NFC adapter to start nfc scanning if (contextWeakRef.get() == null) { throw IllegalStateException(\u0026quot;onStartDetection() failed : no context available\u0026quot;) } if (nfcAdapter == null) { nfcAdapter = NfcAdapter.getDefaultAdapter(contextWeakRef.get()!!) } val flags = flags val options = options nfcAdapter?.enableReaderMode(contextWeakRef.get(), this, flags, options) }  PC/SC Example\n[java] protected void onStartDetection() { //TODO: completion }  onStopDetection() Android NFC Example\n[kotlin] override fun onStopDetection() { //When keyple core stop detection, we invoke native adapter stop NFC scanning nfcAdapter?.let { if (contextWeakRef.get() != null) { it.disableReaderMode(contextWeakRef.get()) } else { throw IllegalStateException(\u0026quot;onStopDetection failed : no context available\u0026quot;) } } }  PC/SC Example\n[java] protected void onStopDetection() { //TODO: completion }  ObservableReaderNotifiers Android NFC Example\n[kotlin] //Note simplified view of Android NFc implementation class AndroidNfcReader(activity: Activity) : //In android NFC, we want an easy way to callback Keyple Core when a card is inserted //because this event occurs through the native layer. AbstractObservableLocalAutonomousReader( AndroidNfcReader.PLUGIN_NAME, AndroidNfcReader.READER_NAME ), //Our reader have an integrated management of card insertion detection WaitForCardInsertionAutonomous, //Our reader do not have an integrated management of card removal detection //but we can use it when the card is no longer in the field and trigger a removal event WaitForCardRemovalBlocking, //We do not want to catch card removal between exchanges with it DontWaitForCardRemovalDuringProcessing{}  PC/SC Example\n[java] //We want to observe card events like insertion, removal... class AbstractPcscReader extends bstractObservableLocalReader implements PcscReader, //Our native reader do not have an integrated management of card insertion detection //but we can use it when the card is in the field and trigger an insertion event WaitForCardInsertionBlocking, //We want to detect when card is removed while exchanging data with our reader WaitForCardRemovalDuringProcessing, //Our native reader do not have an integrated management of card removal detection //but we can use it when the card is no longer in the field and trigger a removal event WaitForCardRemovalBlocking {}  AbstractObservableLocalAutonomousReader onCardInserted() Android NFC Example\n[kotlin] //Note simplified view of Android NFc implementation override fun onTagDiscovered(tag: Tag?) { tag?.let { try { tagProxy = TagProxy.getTagProxy(tag) //onTagDiscovered is triggered natively //we use below code to forward the information to Keyple core onCardInserted() } catch (e: KeypleReaderException) { Timber.e(e) } } }  onCardRemoved() AbstractPlugin initNativeReaders() OMAPI Exemple\n[kotlin] override fun initNativeReaders(): ConcurrentSkipListMap\u0026lt;String, Reader\u0026gt; { val readers = ConcurrentSkipListMap\u0026lt;String, Reader\u0026gt;() //seService is an instance of android.se.omapi.SEService seService?.readers.forEach { nativeReader -\u0026gt; //mapToReader creates an instance of our Keyple reader from a native reader val reader = mapToReader(nativeReader) readers[reader.name] = reader } return readers }  Android NFC Example\n[kotlin] override fun initNativeReaders(): ConcurrentMap\u0026lt;String, Reader\u0026gt;? { val readers = ConcurrentHashMap\u0026lt;String, Reader\u0026gt;() //AndroidNfcReaderImpl is our implementation of Keyple reader readers[AndroidNfcReader.READER_NAME] = AndroidNfcReaderImpl(activity, readerObservationExceptionHandler) return readers }  PC/SC Example\n[java] protected Map\u0026lt;String, Reader\u0026gt; initNativeReaders() { ConcurrentMap\u0026lt;String, Reader\u0026gt; nativeReaders = new ConcurrentHashMap\u0026lt;String, Reader\u0026gt;(); //CardTerminal is a a class from javax.smartcardio CardTerminals terminals = getCardTerminals(); try { for (CardTerminal terminal : terminals.list()) { final PcscReader pcscReader = createReader(this.getName(), terminal); nativeReaders.put(pcscReader.getName(), pcscReader); } } catch (CardException e) { } return nativeReaders; }  AbstractThreadedObservablePlugin fetchNativeReadersNames() PC/SC Example\n[kotlin] public SortedSet\u0026lt;String\u0026gt; fetchNativeReadersNames() { SortedSet\u0026lt;String\u0026gt; nativeReadersNames = new ConcurrentSkipListSet\u0026lt;String\u0026gt;(); CardTerminals terminals = getCardTerminals(); try { for (CardTerminal terminal : terminals.list()) { nativeReadersNames.add(terminal.getName()); } } catch (CardException e) { } return nativeReadersNames; }  fetchNativeReader() PC/SC Example\n[java] protected Reader fetchNativeReader(String name) { // return the current reader if it is already listed Reader reader = readers.get(name); if (reader != null) { return reader; } /* parse the current PC/SC readers list to create the ProxyReader(s) associated with new reader(s) */ CardTerminals terminals = getCardTerminals(); try { for (CardTerminal terminal : terminals.list()) { if (terminal.getName().equals(name)) { reader = createReader(this.getName(), terminal); } } } catch (CardException e) { throw new KeypleReaderIOException(\u0026quot;Could not access terminals list\u0026quot;, e); } if (reader == null) { throw new KeypleReaderNotFoundException(\u0026quot;Reader \u0026quot; + name + \u0026quot; not found!\u0026quot;); } return reader; }  PluginFactory getPluginName() Android NFC Example\n[kotlin] override fun getPluginName(): String { return AndroidNfcPlugin.PLUGIN_NAME }  PC/SC Example\n[java] public String getPluginName() { return PLUGIN_NAME; }  getPlugin() Android NFC Example\n[kotlin] override fun getPlugin(): Plugin { return AndroidNfcPluginImpl(activity, readerObservationExceptionHandler) }  PC/SC Example\n[java] public PcscPlugin getPlugin() { try { if (isOsWin) { return PcscPluginWinImpl.getInstance(); } else { return PcscPluginImpl.getInstance(); } } catch (Exception e) { throw new KeyplePluginInstantiationException(\u0026quot;Can not access smartcard.io readers\u0026quot;, e); } }  Imports JARs All deliverables (JARs, AARs, changelogs, javadocs) are available on the Maven Central Repository.\nSo you can use Gradle or Maven to import the JARs into your project or download them directly from the Maven Central Repository.\nGRADLE  Keyple Java Core  implementation 'org.eclipse.keyple:keyple-java-core:1.0.0'   Keyple Android Plugin NFC  implementation 'org.eclipse.keyple:keyple-android-plugin-nfc:1.0.0'   Keyple Android Plugin OMAPI  implementation 'org.eclipse.keyple:keyple-android-plugin-omapi:1.0.0'   Keyple Java Plugin PC/SC  implementation 'org.eclipse.keyple:keyple-java-plugin-pcsc:1.0.0'  MAVEN  Keyple Java Core  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Keyple Android Plugin NFC  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-nfc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Keyple Android Plugin OMAPI  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-android-plugin-omapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Keyple Java Plugin PC/SC  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.keyple\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;keyple-java-plugin-pcsc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Sources Keyple Android NFC   Plugin  Example App  Keyple Android OMAPI   Plugin  Example App  PC/SC   Plugin  Example Apps  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607614011,"objectID":"2c4fc03bba0d6df540f151dedb1bded5","permalink":"/keyple-website/docs/developer-guide/create-plugin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/create-plugin/","section":"docs","summary":"Overview In order to provide an easy way to port a Keyple application from a device with a specific card reader to another, a plugin system as been developed. When a developer wants to include Keyple features within his project, he has to initialize the SmartCardService by providing a plugin Factory available with in the plugin library.","tags":null,"title":"Create a plugin","type":"book"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607614011,"objectID":"5b04e856432dbaddfeb90dcac213d1aa","permalink":"/keyple-website/docs/developer-guide/create-extension/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/create-extension/","section":"docs","summary":"","tags":null,"title":"Create an extension","type":"book"},{"authors":null,"categories":null,"content":"This guide is intended to help a user of version 0.8.1 of Keyple Java to upgrade his application to the 0.9.0 version of the library.\nFrom a user API point of view, the changes relate to the following topics:\n  plugin registration in the SeProxyService  preparation of selection cases  retrieving selection results  definition of the security settings of the transaction  creation of the PoTransaction object  transaction commands preparation  transaction commands processing  retrieving data read from POs  error handling  Plugin registration in the SeProxyService The registerPlugin method of the SeProxyService class now returns the reference of the registered plugin.\nThis makes it possible, for example, to perform a reader setup in an application such as this one:\n// Create a PcscPlugin and register it into the SeProxyService ReaderPlugin pcscPlugin = seProxyService.registerPlugin(new PcscPluginFactory());` // Get the PO reader from the plugin SeReader poReader = pcscPlugin.getReader(\u0026quot;ASK LoGO 0\u0026quot;);  Preparation of selection cases The AidSelector, Selector and PoSelector classes now follow the Fluent Builder pattern for better handling of optional parameters.\nThe construction of an AidSelector is as follows:\nAidSelector appAidSelector = AidSelector.builder() .aidToSelect(AID) .fileControlInformation(AidSelector.FileControlInformation.FCI) .fileOccurrence(AidSelector.FileOccurrence.FIRST) .build();  The fileControlInformation and fileOccurrence fields are optional (shown here with their default values), so a simple version can be :\nAidSelector aidSelector = AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build();  The construction of a SeSelector is as follows:\nseSelector = SeSelector.builder() .seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4) .aidSelector(appAidSelector) .build();  The PoSelector adds the possibility to specify that an invalidated PO should be processed\nseSelector = SeSelector.builder() .seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4) .aidSelector(appAidSelector) .invalidatedPo(InvalidatedPo.ACCEPT) .build();  The management of PO commands to be performed after the selection step (when it has been successful) is handled by the methods of the PoSelectionRequest class:\n preparing to read files has been simplified and is done using the unique following method:  public void prepareReadRecordFile(byte sfi, int recordNumber)   preparing to select files is done using the following method:  public void prepareSelectFile(byte[] lid) public void prepareSelectFile(short lid)  Note that from now the \u0026ldquo;prepare\u0026rdquo; methods no longer return indexes, the data will be placed in the CalypsoPo object.\nRetrieving selection results The MatchingSelection class no longer exists. In the class SelectionsResult (see processDefaultSelection/processExplicitSelection):\n  getActiveSelection is replaced by getActiveMatchingSe which returns an AbstractMatchingSe object (the still existing hasActiveSelection method must be used before)\n  getMatchingSelection is replaced by getMatchingSe which returns an AbstractMatchingSe object (may be null if the index provided does not correspond to a successful selection case)\n  getMatchingSelections now returns a Map containing a list of associated AbstractMatchingSe with the selection index that produced it (Map\u0026lt;Integer, AbstractMatchingSe\u0026gt;)\n  a new hasSelectionMatched method indicates whether the selection index provided corresponds to a successful selection case\n  a new getActiveSelectionIndex method returns the index of the active selection (the still existing hasActiveSelection method must be used before)\n  Definition of the security settings of the transaction These parameters are defined via the PoSecuritySettings class, whose construction now follows the Fluent Builder pattern.\nAll parameters are optional except the SamResource.\nHere is an example of a complete PoSecuritySettings build:\npoSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource) .sessionDefaultKif(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KIF_PERSO) .sessionDefaultKif(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KIF_LOAD) .sessionDefaultKif(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KIF_DEBIT) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KEY_RECORD_NUMBER_PERSO) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KEY_RECORD_NUMBER_LOAD) .sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KEY_RECORD_NUMBER_DEBIT) .sessionModificationMode(ModificationMode.ATOMIC) .ratificationMode(RatificationMode.CLOSE_RATIFIED) .sessionAuthorizedKvcList(authKvcs) .build();  Creation of the PoTransaction object Since PoSecuritySettings now integrates SamResource, the construction of PoTransaction has evolved slightly.\nHere is an example:\nPoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo), poSecuritySettings);  Transaction commands preparation Just as with the \u0026ldquo;prepare\u0026rdquo; commands used for selection, the \u0026ldquo;prepare\u0026rdquo; commands used for transactions no longer return indexes.\nThe available commands in version 0.9 are:\npublic final void prepareSelectFile(SelectFileControl control) public final void prepareSelectFile(short lid) public final void prepareSelectFile(byte[] lid) public final void prepareReadRecordFile(byte sfi, int recordNumber) public final void prepareReadRecordFile(byte sfi, int firstRecordNumber, int numberOfRecords, int recordSize)) public final void prepareReadCounterFile(byte sfi, int countersNumber) public final void prepareUpdateRecord(byte sfi, int recordNumber, byte[] recordData) public final void prepareWriteRecord(byte sfi, int recordNumber, byte[] recordData) public final void prepareAppendRecord(byte sfi, byte[] recordData) public final void prepareIncreaseCounter(byte sfi, int counterNumber, int incValue) public final void prepareDecreaseCounter(byte sfi, int counterNumber, int decValue)  Transaction commands processing The \u0026ldquo;process\u0026rdquo; commands have also been revised and simplified.\nThey all return void.\nIn case of failure a exception is raised (see below).\npublic final void processOpening(PoTransaction.SessionSetting.AccessLevel accessLevel)  The ModificationMode is no longer required since it is integrated in the PoSecuritySettings.\nParameters previously used to specify that a file is read at login are removed.\nInstead, the first prepareReadFile command will be automatically taken into account.\npublic final void processPoCommands() public final void processPoCommandsInSession() public final void processCancel(ChannelControl channelControl) public final void processClosing(ChannelControl channelControl)  Retrieving data read from POs This is a major evolution of the Keyple API. Previously, data read from Calyspo POs were retrieved by applications using \u0026ldquo;parser\u0026rdquo; methods.\nWith Keyple API 0.9, Calypso PO data is made available in the CalypsoPo object obtained during selection and enriched all along the operations performed with PoTransaction.\nThe public getter methods of CalypsoPo are:\npublic final String getDfName() public final byte[] getDfNameBytes() public final String getApplicationSerialNumber() public final byte[] getApplicationSerialNumberBytes() public final String getAtr() public final String getStartupInfo() public final PoRevision getRevision() public final byte getSessionModification() public final byte getApplicationType() public final byte getApplicationSubtype() public final byte getPlatform() public final byte getSoftwareIssuer() public final byte getSoftwareVersion() public final byte getSoftwareRevision() public final boolean isDeselectRatificationSupported() public final boolean isConfidentialSessionModeSupported() public final boolean isPublicAuthenticationSupported() public final boolean isPinFeatureAvailable() public final boolean isSvFeatureAvailable() public final boolean isDfInvalidated() public final boolean isDfRatified() public final DirectoryHeader getDirectoryHeader() public final ElementaryFile getFileBySfi(byte sfi) public final ElementaryFile getFileByLid(short lid) public final Map\u0026lt;Byte, ElementaryFile\u0026gt; getAllFiles()  Four new classes DirectoryHeader, ElementaryFile, FileHeader and FileData have been added.\nDirectoryHeader The public getters for this class are:\npublic short getLid() public byte[] getAccessConditions() public byte[] getKeyIndexes() public byte getDfStatus() public byte getKif(AccessLevel level) public byte getKvc(AccessLevel level) public String toString()  ElementaryFile The public getters for this class are:\npublic byte getSfi() public FileHeader getHeader() public FileData getData() public String toString()  FileHeader The public getters for this class are:\npublic short getLid() public int getRecordsNumber() public int getRecordSize() public FileType getType() public byte getDfStatus() public boolean isShared() public Short getSharedReference() public byte[] getAccessConditions() public byte[] getKeyIndexes() public String toString()  FileData The public getters for this class are:\npublic byte[] getContent() public byte[] getContent(int numRecord) public byte[] getContent(int numRecord, int dataOffset, int dataLength) public SortedMap\u0026lt;Integer, byte[]\u0026gt; getAllRecordsContent() public int getContentAsCounterValue(int numCounter) public SortedMap\u0026lt;Integer, Integer\u0026gt; getAllCountersValue() public String toString()  So, for example to extract the contents of contract files present in the PO, the code might look like this:\n[...] /* Read all 4 contracts command, record size set to 29 */ poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Contracts, CalypsoClassicInfo.RECORD_NUMBER_1, 4, 29); /* proceed with the sending of commands, don't close the channel */ poTransaction.processPoCommandsInSession(); ElementaryFile efContracts = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_Contracts); SortedMap\u0026lt;Integer, byte[]\u0026gt; records = efContracts.getData().getAllRecordsContent(); for (Map.Entry\u0026lt;Integer, byte[]\u0026gt; entry : records.entrySet()) { logger.info(\u0026quot;Contract #{}: {}\u0026quot;, entry.getKey(), ByteArrayUtil.toHex(entry.getValue())); } [...]  Error handling Since version 0.9, all Keyple exceptions are of the RuntimeException type.\nCatching exceptions is therefore now optional.\nHowever, it is possible to selectively catch certain exceptions in order to deal with particular cases.\nThe new hierarchy of Keyple exceptions is shown here\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603811078,"objectID":"0c708f778edc51e07d87f819c4c14ced","permalink":"/keyple-website/docs/developer-guide/migration-0.8.1-to-0.9.0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/keyple-website/docs/developer-guide/migration-0.8.1-to-0.9.0/","section":"docs","summary":"This guide is intended to help a user of version 0.8.1 of Keyple Java to upgrade his application to the 0.9.0 version of the library.\nFrom a user API point of view, the changes relate to the following topics:","tags":null,"title":"Migration Guide - Keyple Java 0.8.1 to 0.9.0","type":"book"},{"authors":["Calypso Networks Association"],"categories":["Events"],"content":"Are you a mobility aggregator, a system integrator, an event manager, a developer or a multi-mobility startup? Do you want to have easy access to a highly secure and interoperable standard, Calypso®, to reduce your costs and accelerate your developments, to move from a black box to an open and modular solution with access to multiple hardware platforms, to enable partnerships with multimodal transport, building facilities including parking, tourism and events… or just discover what Eclipse Keyple™ is and how it works?\nOn October 15, 2020, we organized a webinar Eclipse Keyple™ for Developers!\nSee the whole event on video:     Discover the presentation.\n","date":1601038643,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603811078,"objectID":"893cbaacbce8fe50e13670aac253661a","permalink":"/keyple-website/post/webinar-eclipse-keyple-developers-oct15-2020/","publishdate":"2020-09-25T14:57:23+02:00","relpermalink":"/keyple-website/post/webinar-eclipse-keyple-developers-oct15-2020/","section":"post","summary":"Are you a mobility aggregator, a system integrator, an event manager, a developer or a multi-mobility startup?","tags":["Eclipse","Keyple","Events","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA","Mobility"],"title":"Webinar Eclipse Keyple™ for Developers, Thursday, October 15, 2020 ","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Release"],"content":"We are pleased to announce that the version 0.9.0 of the Java implementation of Eclipse Keyple™ was released September 11th, 2020.\nThe main improvement on the Calypso® extension is the addition of high-level API to manage the portable object response. Now the APDU responses of the Calypso® cards are automatically parsed to fill card images. Currently all the components of Eclipse Keyple™ Java are following the same versioning.\nFrom the version 1.0.0 scheduled for November 2020, the components will be defined with their own versioning in order to stabilize as possible the different APIs.\n Documentation currently available:\n the project plan, the guides of the different public API, and a guide to manage the migration between the release 0.8.1 \u0026amp; 0.9.0.  ","date":1600433876,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603811078,"objectID":"b73458a3048ddd5b999490db1ff58736","permalink":"/keyple-website/post/release-0-9-0-java/","publishdate":"2020-09-18T14:57:56+02:00","relpermalink":"/keyple-website/post/release-0-9-0-java/","section":"post","summary":"Version 0.9.0 of the Java implementation of Eclipse Keyple™ was released September 11, 2020.","tags":["Eclipse","Keyple","Release","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"Release 0.9.0 Java on the field","type":"post"},{"authors":["Calypso Networks Association"],"categories":["Events"],"content":"On October 17, 2019, we organized the first Meet Up Eclipse Keyple™! Great moments of exchanges around the first Open Source SDK for Ticketing with Benoît Boute, Nicolas Generali, Pierre Terree, Hicham Elbizy, Benoist Laforge, Gaël Blondelle, Camille Moulin, Philippe Vappereau, Valentina Zajackowski. Many thanks to them for their interventions and also to Manon Chaix, Jean-Pierre Fortune, Olivier Delcroix, Ludovic Teixeira Costa and all the participants!\nSee the whole event on video:     Discover the presentation.\n  Discover the photos.\n","date":1571270400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603811078,"objectID":"33404383739ed4d1c8c4bd9333070a94","permalink":"/keyple-website/post/first-meetup-eclipse-keyple/","publishdate":"2019-10-17T00:00:00Z","relpermalink":"/keyple-website/post/first-meetup-eclipse-keyple/","section":"post","summary":"On October 17, 2019, we organized the first Meet Up Eclipse Keyple™!","tags":["Eclipse","Keyple","Events","OpenSource","SDK","API","OpenSolutions","Ticketing","MaaS","CNA"],"title":"First Meet Up Eclipse Keyple™","type":"post"}]