<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer guides | Eclipse Keyple</title><link>https://keyple.org/learn/developer-guide/</link><atom:link href="https://keyple.org/learn/developer-guide/index.xml" rel="self" type="application/rss+xml"/><description>Developer guides</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Â© Eclipse Foundation, Inc. All Rights Reserved.</copyright><image><url>https://keyple.org/images/logo_hu673a59176cd62c570f44ed2728665b48_42188_300x300_fit_lanczos_3.png</url><title>Developer guides</title><link>https://keyple.org/learn/developer-guide/</link></image><item><title>Standalone Application Developer Guide</title><link>https://keyple.org/learn/developer-guide/standalone-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/standalone-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A standalone application is an application that runs in a device in contact
with the end user.&lt;/p>
&lt;p>It has at least one local smart card reader and manages itself the
interaction with the user.&lt;/p>
&lt;p>The diagram below illustrates the organization of a standalone application based on Keyple:
&lt;figure >
&lt;a data-fancybox="" href="../../media/learn/developer-guide/standalone-application/Local_Application_Components_Overview.svg" >
&lt;img src="../../media/learn/developer-guide/standalone-application/Local_Application_Components_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;hr>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>If you are new to Keyple, read the
&lt;a href="../../learn/overview/key-concepts/">key concepts&lt;/a> page and familiarize yourself with the fundamentals behind Keyple.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the
setting up of &lt;strong>Keyple Service&lt;/strong>, please study the
&lt;a href="#workflow">workflow&lt;/a> proposed in the following chapter.&lt;/li>
&lt;li>Explore the
&lt;a href="https://keyple.org/components-java/core/keyple-service-java-lib/">Keyple Service component page&lt;/a> to discover the features and the
possibilities offered by its API.&lt;/li>
&lt;li>Take inspiration from the
&lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the
&lt;a href="https://keyple.org/learn/build-your-first-app/java-app/">Build your first app&lt;/a> section to configure your environment (Gradle / Maven).&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/">Java components&lt;/a> pages, import
&lt;strong>Keyple Service&lt;/strong> and the optional add-ons into your project and start playing with &lt;strong>Keyple&lt;/strong>.&lt;/li>
&lt;li>Don&amp;rsquo;t forget to explore the potential of Keyple card-specific
extensions such as
&lt;a href="https://keyple.org/components-java/card-extensions/keyple-card-calypso-java-lib/">&lt;strong>Keyple Calypso&lt;/strong>&lt;/a>.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;p>&lt;strong>Keyple Service&lt;/strong> is built around the concepts described
&lt;a href="../../learn/overview/key-concepts/">here&lt;/a> and sometimes proposes several ways to perform
an action or to achieve a result depending on the needs of the
application.&lt;/p>
&lt;p>The purpose of this section is to guide you in its use.&lt;/p>
&lt;h2 id="smart-card-service">Smart card service&lt;/h2>
&lt;p>As part of &lt;strong>Keyple Service&lt;/strong> component, the smart card service is the main service of Keyple. Its role is to centralize the add-on resources and to manage their
life cycle.&lt;/p>
&lt;p>The service is accessible by invoking the &lt;code>SmartCardServiceProvider.getService()&lt;/code> static method.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('7', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-7">SmartCardService smartCardService = SmartCardServiceProvider.getService();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="set-up-a-plugin">Set up a plugin&lt;/h2>
&lt;p>The Keyple application developer will choose the reader plugins he needs
according to the equipment on which the Keyple application will run.&lt;/p>
&lt;p>For example, if the environment is PC-based, the PC/SC plugin will probably, but not necessarily, be chosen.
For an Andoid terminal environment, the plugin could be the standard
Android NFC plugin or one of the plugins available from the industrial
partners of the project.&lt;/p>
&lt;p>For a complete list of available plugins, please see
the
&lt;a href="https://keyple.org/components-java/standard-reader-plugins/">standard reader plugins&lt;/a>,
the
&lt;a href="https://keyple.org/components-java/specific-reader-plugins/">specific reader plugins&lt;/a>
or one of our
&lt;a href="https://keyple.org/external-resources/external-add-ons/">partners reader plugins&lt;/a>.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A new plugin can also be &lt;a href="../../learn/developer-guide/create-a-reader-plugin/">created&lt;/a> if there is no plugin for the intended hardware.
&lt;/div>
&lt;/div>
&lt;h3 id="access-to-a-plugin">Access to a plugin&lt;/h3>
&lt;p>To access a plugin at the application level, it must first be registered with the smart card service via the &lt;code>registerPlugin(...)&lt;/code> method.
It will be necessary to provide an implementation of the &lt;code>KeyplePluginExtensionFactory&lt;/code> interface.
This factory is provided by the API of the used plugin.&lt;/p>
&lt;p>Depending on the capabilities of the hardware, the plugin factory may or may not offer specific configuration options.
Please refer to the API of the plugin component you are considering to see what is appropriate for your application.&lt;/p>
&lt;p>The registration provides in return an implementation of one of the &lt;code>Plugin&lt;/code>, &lt;code>ObservablePlugin&lt;/code> or &lt;code>PoolPlugin&lt;/code> interfaces depending on the type of target plugin.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A plugin is identified by a unique name in the system so that it can be retrieved at any time from the smart card service.
&lt;/div>
&lt;/div>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('13', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-13">// Here is for example the registration of the PC/SC plugin
Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build());&lt;/code>&lt;/pre>
&lt;h3 id="configure-a-plugin">Configure a plugin&lt;/h3>
&lt;p>Some plugin types may offer specific options.&lt;/p>
&lt;p>Static options are usually directly exposed by the plugin factory API while dynamic options are exposed by the plugin extension API.&lt;/p>
&lt;p>To access the plugin extension it is necessary to invoke the &lt;code>getExtension(...)&lt;/code> method on the registered &lt;code>Plugin&lt;/code> by specifying the expected class of the extension which must extends the &lt;code>KeyplePluginExtension&lt;/code> interface.
After that, the dedicated methods are available from the resulting object.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('14', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-14">// Here is a snippet showing the usage of the extension of the Stub plugin
plugin
.getExtension(StubPlugin.class)
.unplugReader(&amp;#34;READER_1&amp;#34;);&lt;/code>&lt;/pre>
&lt;h3 id="monitor-a-plugin">Monitor a plugin&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The plugin monitoring only applies to hardware environments in which the readers are removable.
Moreover, only plugins of type &lt;code>ObservablePlugin&lt;/code> can be monitored.
&lt;/div>
&lt;/div>
&lt;p>The observation of reader connections and disconnections is achieved
through a background task managed by &lt;strong>Keyple Service&lt;/strong>.&lt;/p>
&lt;p>To enable these observation mechanisms, it is imperative to provide:&lt;/p>
&lt;ul>
&lt;li>a plugin observer implementing the &lt;code>PluginObserverSpi&lt;/code> interface to be notified of plugin events,&lt;/li>
&lt;li>an exception handler implementing the &lt;code>PluginObservationExceptionHandlerSpi&lt;/code> interface to be notified of errors that may occur during the monitoring or events notifications.&lt;/li>
&lt;/ul>
&lt;p>These two interfaces are available in the &lt;code>org.eclipse.keyple.core.service.spi&lt;/code> package of the &lt;strong>Keyple Service&lt;/strong> component.&lt;/p>
&lt;p>Here is an example of a plugin observer class including an exception handler:&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('16', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-16">class PluginObserver implements PluginObserverSpi, PluginObservationExceptionHandlerSpi {
@Override
public void onPluginEvent(PluginEvent event) {
switch (event.getEventType()) {
case READER_CONNECTED:
// here the processing to be done when a reader is connected
...
break;
case READER_DISCONNECTED:
// here the processing to be done when a reader is disconnected
...
break;
default:
break;
}
}
@Override
public void onPluginObservationError(String pluginName, Throwable e) {
// handle here the plugin exceptions raised while observing the readers
...
}
}&lt;/code>&lt;/pre>
&lt;p>In order to access the dedicated setters, the plugin has to be cast to &lt;code>ObservablePlugin&lt;/code>.&lt;/p>
&lt;p>Since adding an observer will cause the &lt;strong>Keyple Service&lt;/strong> to check for the presence of an exception handler,
the definition of the exception handler must be done first.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('17', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-17">PluginObserver pluginObserver = new PluginObserver();
((ObservablePlugin) plugin).setPluginObservationExceptionHandler(pluginObserver);
((ObservablePlugin) plugin).addObserver(pluginObserver);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Note that the monitoring thread only works if there is at least one observer registered, and the notification process is sequential and synchronous.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="set-up-a-reader">Set up a reader&lt;/h2>
&lt;p>The readers are provided by the plugins, that&amp;rsquo;s why you have to
&lt;a href="#set-up-a-plugin">set up the plugin&lt;/a> first.&lt;/p>
&lt;h3 id="access-to-a-reader">Access to a reader&lt;/h3>
&lt;p>The hardware readers already connected are referenced in the system during the registration of the plugin.
For observable plugins, the references of the connected readers are updated in real time.&lt;/p>
&lt;p>Readers are accessible directly from the associated &lt;code>Plugin&lt;/code> instance.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('19', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-19">// Here is an example to get the 1st available reader
String readerName = plugin.getReaderNames().get(0);
Reader reader = plugin.getReader(readerName);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Depending on the type of plugin, the reader names are
more or less dynamic (e.g. a PC/SC based system vs. an embedded
terminal), it is sometimes necessary to implement an identification
mechanism in order to assign the right reader to the right place in the
system (for example by using regular expressions).
&lt;/div>
&lt;/div>
&lt;h3 id="configure-a-reader">Configure a reader&lt;/h3>
&lt;p>There are two types of configuration. Their availability depends on the characteristics of the reader:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The reader is an instance of &lt;code>ConfigurableReader&lt;/code>:&lt;br>
It is then possible to activate or deactivate the protocols supported by the reader.&lt;/p>
&lt;div class="alert alert-note">&lt;div>Use of these methods may be optional if the application does not intend to target products by protocol filtering.&lt;/div>&lt;/div>
&lt;/li>
&lt;li>
&lt;p>The reader&amp;rsquo;s extension API exposes specific options:&lt;br>
To access the reader extension it is necessary to invoke the &lt;code>getExtension(...)&lt;/code> method on the &lt;code>Reader&lt;/code> instance by specifying the expected class of the extension which must extends the &lt;code>KeypleReaderExtension&lt;/code> interface.
After that, the dedicated methods, if any, are available from the resulting object.
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('21', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-21">// Here is a snippet showing the usage of the extension of the Stub reader
reader
.getExtension(StubReader.class)
.removeCard();&lt;/code>&lt;/pre>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="monitor-a-reader">Monitor a reader&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The reader monitoring only applies to hardware environments in which the smart cards are removable.
Moreover, only readers of type &lt;code>ObservableReader&lt;/code> can be monitored.
&lt;/div>
&lt;/div>
&lt;div class="alert alert-note">
&lt;div>
Observation of the readers is optional in Keyple. It facilitates an event-driven programming mode, but an application
developer can choose not to observe a reader, either because this reader is not designed to manage card insertions/withdrawals (for example an
Android OMAPI reader or a SAM reader), or because the application is designed to directly manage the presence of a card (see to &lt;code>isCardPresent&lt;/code> method of the
&lt;code>Reader&lt;/code> interface).
&lt;/div>
&lt;/div>
&lt;p>The observation of card insertions and removals is achieved
through a background task managed by &lt;strong>Keyple Service&lt;/strong>.&lt;/p>
&lt;p>To enable these observation mechanisms, it is imperative to provide:&lt;/p>
&lt;ul>
&lt;li>a reader observer implementing the &lt;code>CardReaderObserverSpi&lt;/code> interface to be notified of reader events,&lt;/li>
&lt;li>an exception handler implementing the &lt;code>CardReaderObservationExceptionHandlerSpi&lt;/code> interface to be notified of errors that may occur during the monitoring or events notifications.&lt;/li>
&lt;/ul>
&lt;p>These two interfaces are available in the &lt;code>org.calypsonet.terminal.reader.spi&lt;/code> package of the &lt;strong>Calypsonet Terminal Reader API&lt;/strong> component.&lt;/p>
&lt;p>Here is an example of a reader observer class including an exception handler:&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('24', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-24">class ReaderObserver implements CardReaderObserverSpi, CardReaderObservationExceptionHandlerSpi {
@Override
public void onReaderEvent(CardReaderEvent event) {
switch (event.getType()) {
case CardReaderEvent.Type.CARD_INSERTED:
// here the processing to be done when a card is inserted
...
break;
case CardReaderEvent.Type.CARD_REMOVED:
// here the processing to be done when a card is removed
...
break;
default:
break;
}
}
@Override
public void onReaderObservationError(String pluginName, String readerName, Throwable e) {
// handle here the reader exceptions raised while observing the cards
...
}
}&lt;/code>&lt;/pre>
&lt;p>In order to access the dedicated setters, the reader has to be cast to &lt;code>ObservableReader&lt;/code>.&lt;/p>
&lt;p>Since adding an observer will cause the &lt;strong>Keyple Service&lt;/strong> to check for the presence of an exception handler,
the definition of the exception handler must be done first.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('25', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-25">ReaderObserver readerObserver = new ReaderObserver();
((ObservableReader) reader).setReaderObservationExceptionHandler(readerObserver);
((ObservableReader) reader).addObserver(readerObserver);
((ObservableReader) reader).startCardDetection(ObservableCardReader.DetectionMode.REPEATING);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Note that the &lt;code>startCardDetection(...)&lt;/code> and &lt;code>stopCardDetection()&lt;/code> methods start and stop the monitoring thread.
The API offers different options to manage the needs around card detection.&lt;br>
Moreover, the notification process is sequential and synchronous.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="select-a-card">Select a card&lt;/h2>
&lt;p>The starting point of any processing done with a card in the Keyple enrivonment, is to reference this card in the system.
It is the role of the selection step to obtain this reference.&lt;/p>
&lt;p>You have first to prepare a selection scenario defining the eligible cards for a transaction, then to execute the scenario when a card is presented.&lt;/p>
&lt;p>The Keyple card selection process is generic, allowing the management of cards of different types
or technologies within the same application.&lt;/p>
&lt;p>It is based on the universal selection interface defined by the
&lt;a href="../../components-java/standards-compliance/calypsonet-apis/">&lt;strong>Calypsonet Terminal Reader Java API&lt;/strong>&lt;/a>.&lt;/p>
&lt;p>A &lt;code>CardSelectionManager&lt;/code> is obtained from the Keyple &lt;code>SmartCardService&lt;/code>
using the &lt;code>createCardSelectionManager&lt;/code> method.&lt;/p>
&lt;p>It allows the addition of &amp;ldquo;selection cases&amp;rdquo; corresponding to an expected target card.&lt;/p>
&lt;p>These selection cases are represented by objects implementing the &lt;strong>Calypsonet Terminal Reader Java API&lt;/strong>
interface &lt;code>CardSelection&lt;/code>; these objects should be provided by a Keyple Card Extension add-on.&lt;/p>
&lt;p>Providing one or more selection cases to the &lt;code>CardSelectionManager&lt;/code> constitutes a &lt;em>selection scenario&lt;/em>.
The scenario is run by &lt;strong>Keyple Service&lt;/strong> when a card is detected, the different cases being evaluated
sequentially as long as the card does not match the criteria of the defined cases.&lt;/p>
&lt;p>The selection process for a case offers several options for selecting a processing based on the type of card presented to the reader.&lt;/p>
&lt;p>It is based on a filtering process according to three possible criteria,
each of which is optional:&lt;/p>
&lt;ul>
&lt;li>the communication protocol of the card (usually also identifying a
card technology)&lt;/li>
&lt;li>the power-on data collected by the reader when the card is detected (e.g. the Answer To Reset)&lt;/li>
&lt;li>the ISO standard application identifier (AID) used to perform a Select Application command.&lt;/li>
&lt;/ul>
&lt;p>When a card is inserted, it is evaluated according to these criteria and
will be given the status &amp;ldquo;selected&amp;rdquo; or not.&lt;/p>
&lt;p>When a card is not selected, no other operation will be possible with it.&lt;/p>
&lt;p>Depending on the chosen setting (see &lt;code>setMultipleSelectionMode&lt;/code>), the result of the selection will or will not
be made available to the application.
It is thus possible to directly ignore cards that do not correspond to the defined selection criteria.&lt;/p>
&lt;p>When a card is selected, the &lt;code>CardSelectionManager&lt;/code> will make available the result
as a &lt;code>SmartCard&lt;/code> object containing all the information known about the card at that stage.&lt;/p>
&lt;p>Depending on the card extension that is used, this &lt;code>SmartCard&lt;/code> object can be cast to a more
comprehensive object with specific features defined by the extension.&lt;/p>
&lt;p>In addition to the selection process itself, specific APDU commands may be sent to the card if the selection is successful.
The output of these commands is available in the instance of the &lt;code>SmartCard&lt;/code> object or its derivative.&lt;/p>
&lt;h3 id="prepare-a-selection-scenario">Prepare a selection scenario&lt;/h3>
&lt;h3 id="process-a-selection-scenario">Process a selection scenario&lt;/h3>
&lt;h3 id="schedule-a-selection-scenario">Schedule a selection scenario&lt;/h3>
&lt;hr>
&lt;h2 id="perform-a-transaction">Perform a transaction&lt;/h2>
&lt;hr>
&lt;h2 id="unregister-a-plugin">Unregister a plugin&lt;/h2>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;h2 id="card-selection">Card selection&lt;/h2>
&lt;h2 id="card-selection-and-reader-observation">Card selection and reader observation&lt;/h2>
&lt;p>The &lt;code>CardSelectionManager&lt;/code> performs card selection in two steps:&lt;/p>
&lt;ul>
&lt;li>a first step of preparing the selection scenario,&lt;/li>
&lt;li>a second step of running the prepared scenario.&lt;/li>
&lt;/ul>
&lt;p>The first step is done by invoking the &lt;code>prepareSelection&lt;/code> method with a &lt;code>CardSelection&lt;/code> object defining
a selection profile as argument. This is to be repeated as many times as there are selection cases.&lt;/p>
&lt;p>The second step, the scenario execution, can be done in two ways:&lt;/p>
&lt;ul>
&lt;li>by directly executing the scenario with &lt;code>processCardSelectionScenario&lt;/code> when the presence of the card is managed
by the application,&lt;/li>
&lt;li>by feeding the observation mechanism with the scenario by invoking the &lt;code>scheduleCardSelectionScenario&lt;/code> when
the reader is observed.&lt;/li>
&lt;/ul>
&lt;p>In the first case, the result obtained directly in &lt;code>CardSelectionResult&lt;/code> in return of
&lt;code>processCardSelectionScenario&lt;/code>.&lt;/p>
&lt;p>In the latter case, the result is passed to the application in the &lt;code>ScheduledCardSelectionsResponse&lt;/code> field of
&lt;code>ReaderEvent&lt;/code> and is to be retrieved using &lt;code>parseScheduledCardSelectionsResponse&lt;/code>.&lt;/p>
&lt;p>Note that the scheduling of the execution of a scenario includes two options:&lt;/p>
&lt;ul>
&lt;li>the &lt;code>DetectionMode&lt;/code> defining the expected behavior regarding the card detection allowing to automatically restart it or not.&lt;/li>
&lt;li>the &lt;code>NotificationMode&lt;/code> allowing to choose if only the cards matching the selection (successfully selected) should trigger an event.&lt;/li>
&lt;/ul>
&lt;h2 id="card-selection-in-practice">Card selection in practice&lt;/h2>
&lt;p>In this chapter we will show step by step how to use the selection service with the generic card extension.&lt;/p>
&lt;h3 id="create-the-card-selection-manager">Create the card selection manager&lt;/h3>
&lt;p>The card selection manager will be used all along the card selection process.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('28', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-28">// Get the core card selection manager.
CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager();```&lt;/code>&lt;/pre>
&lt;h3 id="prepare-and-add-the-selection-cases">Prepare and add the selection cases&lt;/h3>
&lt;p>The application can create as many selection cases as the type of cards
expected. The order in which the selection cases are prepared is
important because it will favor the latency delay for the processing of
the cards corresponding to the first case. It is therefore recommended
to place the most common card profile in the application context first.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('29', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-29">// prepare a selection for application 1
cardSelectionManager.prepareSelection(
GenericExtensionService.getInstance()
.createCardSelection()
.filterByDfName(AID1));
// prepare a selection for application 2
cardSelectionManager.prepareSelection(
GenericExtensionService.getInstance()
.createCardSelection()
.filterByDfName(AID2));&lt;/code>&lt;/pre>
&lt;h4 id="proceed-to-the-selection-with-a-non-observable-reader">Proceed to the selection with a non-observable reader&lt;/h4>
&lt;p>The &lt;code>processCardSelectionScenario&lt;/code> method of &lt;code>CardSelectionManager&lt;/code> performs the actual
communication with the card.
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('30', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-30">// Actual card communication: run the selection scenario.
CardSelectionResult selectionResult = cardSelectionManager.processCardSelectionScenario(reader);
// Check the selection result.
if (selectionResult.getActiveSmartCard() == null) {
throw new IllegalStateException(&amp;#34;The selection of the card failed.&amp;#34;);
}
// Get the SmartCard resulting of the selection.
SmartCard smartCard = selectionResult.getActiveSmartCard();&lt;/code>&lt;/pre>&lt;/p>
&lt;h4 id="proceed-to-the-selection-with-an-observable-reader">Proceed to the selection with an observable reader&lt;/h4>
&lt;p>In the case of an observable reader, the prepared request is provided
to the reader (it is then named Default Selection) and will be processed
automatically as soon as a card is presented. The application is then
notified of the event with the data resulting from the selection.
Depending on the selection settings, the application will be notified of
all card presentations (&lt;code>CARD_INSERTED&lt;/code> event) or only those
presentations that led to a successful selection (&lt;code>CARD_MATCHED&lt;/code>
event).&lt;/p>
&lt;h5 id="add-a-default-selection">Add a default selection&lt;/h5>
&lt;pre>&lt;code class="language-java">// Provide the Reader with the selection operation to be processed when a card is inserted.
((ObservableReader) reader)
.setDefaultSelectionRequest(
cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(),
ObservableReader.NotificationMode.MATCHED_ONLY,
ObservableReader.PollingMode.REPEATING);
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>NotificationMode&lt;/code> allows you to specify whether all card
insertions should be reported to the application or only those that led
to a successful selection.&lt;/p>
&lt;p>&lt;code>PollingMode&lt;/code> indicates whether to go back to waiting for the card
after processing (&lt;code>REPEATING&lt;/code>) or let the application decide when to
restart the search (&lt;code>SINGLESHOT&lt;/code>) with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;p>Note: when the default selection is set with the &lt;code>PollingMode&lt;/code>
parameter, the card detection is started automatically. However, it is
possible to set a default selection without automatic start and by
starting the detection independently with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;h5 id="receive-the-result-as-an-event">Receive the result as an event&lt;/h5>
&lt;pre>&lt;code class="language-java">...
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_MATCHED:
AbstractSmartCard selectedCard = null;
try {
selectedCard =
getDefaultSelection()
.processDefaultSelectionsResponse(event.getDefaultSelectionsResponse())
.getActiveSmartCard();
} catch (KeypleException e) {
logger.error(&amp;quot;Exception: {}&amp;quot;, e.getMessage());
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
if (selectedCard != null) {
logger.info(&amp;quot;Observer notification: the selection of the card has succeeded.&amp;quot;);
// insert the processing of the card here
...
logger.info(&amp;quot;= #### End of the card processing.&amp;quot;);
} else {
logger.error(
&amp;quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
}
break;
case CARD_INSERTED:
logger.error(
&amp;quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
break;
case CARD_REMOVED:
logger.trace(&amp;quot;There is no PO inserted anymore. Return to the waiting state...&amp;quot;);
break;
default:
break;
}
if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED
|| event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) {
// Informs the underlying layer of the end of the card processing, in order to manage the
// removal sequence.
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
}
...
&lt;/code>&lt;/pre>
&lt;h4 id="get-the-selection-result">Get the selection result&lt;/h4>
&lt;p>The result of the selection is available in the &lt;code>AbstractSmartCard&lt;/code>
object.&lt;/p>
&lt;pre>&lt;code class="language-java">...
if (!cardSelectionsResult.hasActiveSelection()) {
logger.warn(&amp;quot;The selection of the application &amp;quot; + cardAid + &amp;quot; failed.&amp;quot;);
}
AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard();
logger.info(&amp;quot;The selection of the card has succeeded.&amp;quot;);
if (smartCard.hasFci()) {
String fci = ByteArrayUtil.toHex(smartCard.getFciBytes());
logger.info(&amp;quot;Application FCI = {}&amp;quot;, fci);
}
if (smartCard.hasAtr()) {
String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes());
logger.info(&amp;quot;Card ATR = {}&amp;quot;, atr);
}
...
&lt;/code>&lt;/pre>
&lt;h2 id="implementation-of-the-application-service">Implementation of the application service&lt;/h2>
&lt;p>The applicative processing of the card that follows the selection of the
card is to be inserted in the processing of the &lt;code>CARD_INSERTED&lt;/code> or
&lt;code>CARD_MATCHED&lt;/code> event.&lt;/p>
&lt;p>It can be processed in the thread provided by the monitoring task or
detached in a separate thread. The application developer must pay
attention to the handling of exceptions in this part of the application.
Indeed, in case of a runtime exception, the information will be given to
the application via the exception handler configured beforehand.&lt;/p>
&lt;h2 id="stopping-the-application">Stopping the application&lt;/h2>
&lt;p>The clean shutdown of a Keyple application requires the release of
resources and in particular the shutdown of the observation threads.&lt;/p>
&lt;p>This is done by unregistering the plugins in the following way:&lt;/p>
&lt;pre>&lt;code class="language-java">smartCardService.unregisterPlugin(plugin.getName());
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="keyple-service-api">Keyple Service API&lt;/h2>
&lt;p>To learn all the details of the &lt;strong>Keyple Service&lt;/strong> API, please consult the
&lt;a href="https://keyple.org/docs-1.0/api-reference/">Javadoc documentation&lt;/a>.&lt;/p>
&lt;p>However, here are two diagrams showing the main features of &lt;strong>Keyple Service&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the
&lt;strong>Smart Card Service&lt;/strong> with in particular the observation mechanisms.
&lt;figure >
&lt;a data-fancybox="" href="../../media/archive-1.0/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" >
&lt;img src="../../media/archive-1.0/architecture/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The diagram below represents the main classes used for selection
operations.
&lt;figure >
&lt;a data-fancybox="" href="../../media/archive-1.0/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" >
&lt;img src="../../media/archive-1.0/architecture/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples-1">Examples&lt;/h2>
&lt;p>To help in the implementation of the different facilities offered by
Keyple to process smart cards, a set of examples is present in the
project repository
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone" target="_blank" rel="noopener">
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i> examples&lt;/a>&lt;/p>
&lt;p>Nevertheless, you will find below a brief description of them:&lt;/p>
&lt;h2 id="explicit-selection">Explicit Selection&lt;/h2>
&lt;p>Shows the use of Keyple to make a card selection without observing the
reader, based on testing the presence of the card by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase1_ExplicitSelectionAid" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h2 id="default-selection">Default Selection&lt;/h2>
&lt;p>Shows the use of Keyple to make a card selection with observation of the
reader. A default selection is prepared, the presentation of a card
triggers the notification of a reader event to the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase2_DefaultSelectionNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h2 id="sequential-multiple-selection">Sequential Multiple Selection&lt;/h2>
&lt;p>Executes successively several independent selection operations with the
use of the ISO &amp;lsquo;NEXT&amp;rsquo; navigation flag.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase3_SequentialMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;p>Illustrates the case of a card exploration with maintenance of the physical channel open.&lt;/p>
&lt;h2 id="grouped-multiple-selection">Grouped Multiple Selection&lt;/h2>
&lt;p>Executes a multiple selection with logical channel closure between each
selection.&lt;/p>
&lt;p>Allows the exploration of the applications of a card in a single
operation but without selection at the end.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/blob/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/UseCase4_GroupedMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h2 id="demo-card-protocol-detection">Demo Card Protocol Detection&lt;/h2>
&lt;p>Demonstrates the use of Keyple in a context where several card
technologies are likely to be processed by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_CardProtocolDetection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h2 id="demo-observable-reader-notification">Demo Observable Reader Notification&lt;/h2>
&lt;p>Demonstrates the use of Keyple to implement the observation of a plugin
and its readers. Readers are dynamically created and an observer is
assigned to them.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/standalone/src/main/java/org/eclipse/keyple/example/generic/centralized/Demo_ObservableReaderNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="download-1">Download&lt;/h2></description></item><item><title>Distributed Application Developer Guide</title><link>https://keyple.org/learn/developer-guide/distributed-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/distributed-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Keyple provides the &amp;ldquo;Keyple Distributed&amp;rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal&lt;/strong>.&lt;/p>
&lt;p>In this way, you can manage transactions within a distributed architecture.&lt;/p>
&lt;p>The diagram below shows the location of the &lt;strong>Keyple Distributed&lt;/strong> components in the software layers used in a distributed architecture:&lt;/p>
&lt;figure id="figure-keyple-distributed---solution-layers-overview">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_solution_layers_overview.svg" data-caption="Keyple Distributed - Solution layers overview">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_solution_layers_overview.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Solution layers overview
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="how-to-use-it-">How to use it ?&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read
&lt;a href="../../learn/developer-guide/standalone-application/">Standalone Application Developer Guide&lt;/a> to understand the main concepts of Keyple in a standalone application.&lt;/li>
&lt;li>Read chapter
&lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/li>
&lt;li>Using chapter
&lt;a href="#usage-modes">Usage modes&lt;/a>, find your usage mode. This will help you to determine exactly which library and API to use.&lt;/li>
&lt;li>Using chapter
&lt;a href="#download">Download&lt;/a>, import into your project the libraries specified by your usage mode.&lt;/li>
&lt;li>Using chapter
&lt;a href="#network-configuration">Network configuration&lt;/a>, implement the transport layer adapted to your network configuration.&lt;/li>
&lt;li>Implement your ticketing services as specified in the associated usage mode.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this developer guide:&lt;/p>
&lt;div id="concepts-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Concept&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Remote Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-remote-java-lib&lt;/code> library.&lt;br>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-local-java-lib&lt;/code> library.&lt;br>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-network-java-lib&lt;/code> library.&lt;br>It must always be imported because it contains the network elements used by &lt;strong>Remote Lib&lt;/strong> and &lt;strong>Local Lib&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple reader plugin extension which provides only &lt;strong>Remote Readers&lt;/strong> to the application. It manages data exchanges with the &lt;strong>Local Service&lt;/strong>. This reader plugin extension must be registered to the smart card service like any Keyple reader plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Reader&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple reader extension which has some specificities:&lt;br>- each remote reader is connected to a local reader;&lt;br>- any command sent by the application to a remote reader will be forwarded to the associated local reader;&lt;br>- in some cases only, an event occurring on a local reader or plugin will be automatically forwarded to the associated remote reader or plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Local Lib&lt;/strong>, this is a Keyple distributed local service extension which ensures data exchange between the &lt;strong>Remote Plugin&lt;/strong> and local plugins and readers. It must be registered to the smart card service.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific factory class to initialize them.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each are bind to a specific internal node which is responsible for the interfacing with the &lt;strong>Network Endpoint&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Endpoint&lt;/strong>&lt;/td>
&lt;td>At the user&amp;rsquo;s charge, this component ensures the network exchanges between the &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> nodes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#concepts-table-1 table th:first-of-type {
width: 130px;
}
&lt;/style>
&lt;p>The diagram below illustrates the main functional concepts through a standard use case:&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---main-use-case">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_1.svg" data-caption="Keyple Distributed - Concepts - Main use case">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_1.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - Main use case
&lt;/figcaption>
&lt;/figure>
&lt;p>The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.&lt;/p>
&lt;p>These could be for example a ticketing reloading service, where the business logic would be on the terminal without local readers, with thin clients on A &amp;amp; B terminals communicating locally with the cards.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for card communication.&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---one-remote-plugin-connected-to-many-local-services">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_2.svg" data-caption="Keyple Distributed - Concepts - One remote plugin connected to many local services">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_2.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - One remote plugin connected to many local services
&lt;/figcaption>
&lt;/figure>
&lt;p>Here is another example, but this time it illustrates several remote plugins connected to the same local service.&lt;/p>
&lt;p>These could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for SAM communication.&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---many-remote-plugins-connected-to-one-local-service">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_3.svg" data-caption="Keyple Distributed - Concepts - Many remote plugins connected to one local service">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_3.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - Many remote plugins connected to one local service
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="usage-modes">Usage modes&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution offers two different usage modes, each one having a specific API designed on a &lt;strong>Client-Server&lt;/strong> model:&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Usage mode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#reader-client-side">Reader Client Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. Card reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#reader-server-side">Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader, HSM).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 190px;
}
&lt;/style>
&lt;p>Each mode provides a different &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> and their associated factories.&lt;/p>
&lt;p>In an application, it is possible to use simultaneously several usage modes and as many instances of a usage mode as you want, as long as the components are initialized with different names.&lt;/p>
&lt;h3 id="reader-client-side">Reader Client Side&lt;/h3>
&lt;p>This usage mode allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. Card reader).&lt;/p>
&lt;p>In this mode, the client is the initiator of the application processing following the local plugin or reader events (reader connection/disconnection or card insertion/removal).&lt;/p>
&lt;p>He can hand over to the server whenever he wants to perform a remote ticketing service on a card present in one of his local readers.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service / Remote Plugin&lt;/strong>&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;td>&lt;code>ObservablePlugin&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service / Remote Plugin extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClient&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;td>&lt;code>RemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-warning">
&lt;div>
It is the responsibility of the client application to observe and configure the local plugins and readers.
&lt;/div>
&lt;/div>
&lt;h4 id="operating-mode">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Server&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>RemotePluginServerFactory&lt;/code> using the &lt;code>RemotePluginServerFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Remote Plugin&lt;/strong> to be registered and your network endpoint implementation if required.&lt;/li>
&lt;li>Register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Cast the registered plugin into an &lt;code>ObservablePlugin&lt;/code> and add an event observer to it.&lt;br>&lt;div class="alert alert-note">&lt;div>Please note that this remote plugin is observable only to trigger ticketing services on the server side, but does not allow observation on the local plugin such as reader connection or disconnection.&lt;/div>&lt;/div>&lt;/li>
&lt;li>Await for events of type &lt;code>PluginEvent.Type.READER_CONNECTED&lt;/code>.&lt;br>&lt;div class="alert alert-note">&lt;div>This type of event indicates to the server that a client asks it to perform a specific ticketing service using the connected remote reader.&lt;/div>&lt;/div>&lt;/li>
&lt;li>When an event occurs, you must retrieve the connected remote reader from the registered plugin using the name of the reader contained in the event.&lt;br>&lt;div class="alert alert-note">&lt;div>Please note that the remote reader is strictly an instance of &lt;code>Reader&lt;/code>, even if the local reader is an &lt;code>ObservableReader&lt;/code>.&lt;br>This usage mode does not allow to observe reader events such as card insertion or removal from the server.&lt;br>It is the responsibility of the client to observe the local reader if needed, then to ask the server to execute a specific remote service depending on the case.&lt;/div>&lt;/div>&lt;/li>
&lt;li>Use information inside the &lt;code>RemoteReaderServer&lt;/code> extension of the remote reader to identify the ticketing service to execute.&lt;/li>
&lt;li>Execute the specified ticketing service using the remote reader and all of its other information.&lt;/li>
&lt;li>End the remote ticketing service by invoking the associated method provided by the &lt;code>RemotePluginServer&lt;/code> extension of the remote plugin.&lt;br>It is then possible to send additional information to the client if necessary.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Client&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>LocalServiceClientFactory&lt;/code> using the &lt;code>LocalServiceClientFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Local Service&lt;/strong> to be registered and your network endpoint implementation.&lt;/li>
&lt;li>Register the &lt;strong>Local Service&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Register at least a local plugin to the smart card service and get the name of the local reader to connect to the server.&lt;/li>
&lt;li>Execute the desired remote service by invoking the associated method provided by the &lt;code>LocalServiceClient&lt;/code> extension of the local service by specifying the identifier of the ticketing service to be executed, the name of the target local reader, and transmitting to the server if necessary the contents of the previously read smart card or additional information.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="reader-server-side">Reader Server Side&lt;/h3>
&lt;p>This usage mode allows a &lt;strong>client&lt;/strong> application to control a smart card reader or a pool of smart card readers available on a &lt;strong>server&lt;/strong> (e.g. SAM reader, HSM).&lt;/p>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution offers for this usage mode a remote control of all types of plugins (&lt;code>Plugin&lt;/code>, &lt;code>ObservablePlugin&lt;/code>, &lt;code>PoolPlugin&lt;/code>):&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Regular plugin&lt;/strong> (&lt;code>Plugin&lt;/code> or &lt;code>ObservablePlugin&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>During the remote plugin registration process, the client automatically creates a remote reader for each local reader of the set of local plugins on the server.&lt;/p>
&lt;p>If the factory has been properly configured, then the remote plugin and reader behave like the local plugins and readers.&lt;/p>
&lt;p>It is then possible to observe directly from the client the plugin and/or reader events (reader connection/disconnection or card insertion/removal) if desired.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode in the case of a &lt;strong>regular plugin&lt;/strong>.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>Plugin&lt;/code> * or&lt;br>&lt;code>ObservablePlugin&lt;/code> *&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> * or&lt;br>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemoteReaderClient&lt;/code>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>Pool plugin&lt;/strong> (&lt;code>PoolPlugin&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>The dynamic reader allocation process will search for the first available reader among all or a subset of the pool plugins registered on the server.&lt;/p>
&lt;p>It is possible to define during the configuration phase of the local service factory a filter on the names of the pool plugins to use.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode in the case of a &lt;strong>pool plugin&lt;/strong>.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePoolPluginClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolPlugin&lt;/code> *&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> *&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemoteReaderClient&lt;/code>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-warning">
&lt;div>
Whatever the type of plugin, it is the responsibility of the server application to configure the local plugins and readers.
&lt;/div>
&lt;/div>
&lt;h4 id="operating-mode-1">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Server&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>LocalServiceServerFactory&lt;/code> using the &lt;code>LocalServiceServerFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Local Service&lt;/strong> to be registered and your network endpoint implementation if required.&lt;/li>
&lt;li>Register the &lt;strong>Local Service&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Register at least a local plugin or pool plugin to the smart card service, depending on your case.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Client&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>RemotePluginClientFactory&lt;/code> using the &lt;code>RemotePluginClientFactoryBuilder&lt;/code> or &lt;code>RemotePoolPluginClientFactoryBuilder&lt;/code> class depends on the type of plugin that you want to manage, specifying a unique name for the &lt;strong>Remote Plugin&lt;/strong> to be registered and your network endpoint implementation.&lt;/li>
&lt;li>Register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Use the registered remote plugin as a local plugin.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="network-configuration">Network configuration&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution &lt;strong>does not provide&lt;/strong> the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components.&lt;/p>
&lt;h3 id="synchronous">Synchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Client-Server &lt;strong>Synchronous&lt;/strong> communication protocol, such as standard HTTP for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Network endpoint SPI to be implemented&lt;/td>
&lt;td>&lt;code>SyncEndpointClientSpi&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>SyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>SyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withSyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method provided by the remote plugin or local service extension&lt;br>to use to access the node&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>getSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement in a context with a &lt;strong>single server instance&lt;/strong>:&lt;/p>
&lt;figure id="figure-keyple-distributed---synchronous-network-implementation">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_synchronous.svg" data-caption="Keyple Distributed - Synchronous network implementation">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_synchronous.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Synchronous network implementation
&lt;/figcaption>
&lt;/figure>
&lt;p>In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a &lt;code>serverNodeId&lt;/code> are routed to the server associated with a &lt;code>SyncNodeServer&lt;/code> node having the &lt;code>serverNodeId&lt;/code>.&lt;/p>
&lt;h3 id="asynchronous">Asynchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Full-Duplex &lt;strong>Asynchronous&lt;/strong> communication protocol, such as Web Sockets for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Network endpoint SPI to be implemented&lt;/td>
&lt;td>&lt;code>AsyncEndpointClientSpi&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncEndpointServerSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>AsyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method provided by the remote plugin or local service extension&lt;br>to use to access the node&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code>&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement:&lt;/p>
&lt;figure id="figure-keyple-distributed---asynchronous-network-implementation">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_asynchronous.svg" data-caption="Keyple Distributed - Asynchronous network implementation">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_asynchronous.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Asynchronous network implementation
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="exchanged-data">Exchanged data&lt;/h3>
&lt;p>The data exchanged between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components are contained in the DTO (Data Transfer Object) &lt;code>MessageDto&lt;/code>. It is built and processed by the plugin and &lt;strong>you don&amp;rsquo;t need to modify it&lt;/strong>.&lt;/p>
&lt;p>However, it is necessary in some contexts to access certain information such as the &lt;code>sessionId&lt;/code> in the case of asynchronous communication or the &lt;code>serverNodeId&lt;/code> in the case of synchronous communication with several server instances.&lt;/p>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-local-java-lib" target="_blank" rel="noopener">Local API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-network-java-lib" target="_blank" rel="noopener">Network API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-remote-java-lib" target="_blank" rel="noopener">Remote API&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java-example" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/distributed/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso application</title><link>https://keyple.org/learn/developer-guide/calypso-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/calypso-application/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Card Resource Service Developer Guide</title><link>https://keyple.org/learn/developer-guide/card-resource-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/card-resource-service/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>An application that performs secure transactions on smart cards may need to dynamically allocate a card resource dedicated to the current transaction to manage the security of the transaction (e.g. SAM or HSM).&lt;/p>
&lt;p>To meet this need, Keyple proposes the &lt;strong>Service Resource&lt;/strong> component which provides a service that supports dynamic card resource allocation, using a profile-based filtering mechanism.&lt;/p>
&lt;hr>
&lt;h2 id="features">Features&lt;/h2>
&lt;ul>
&lt;li>card resource locking during use;&lt;/li>
&lt;li>automatic monitoring of observable plugins and readers;&lt;/li>
&lt;li>customizable profile-based filtering mechanism (specific plugins list, reader name using regular expression, reader group name for pool plugins, specific card selection);&lt;/li>
&lt;li>specific reader configuration capability;&lt;/li>
&lt;li>allocation priority management;&lt;/li>
&lt;li>two allocation modes (blocking, non-blocking);&lt;/li>
&lt;li>multiple allocation strategies (first available card resource, cyclic, random);&lt;/li>
&lt;li>configurable allocation timeout;&lt;/li>
&lt;li>failure management.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;ol>
&lt;li>
&lt;a href="#access-to-the-service">Access to the service&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#access-to-the-configurator">Access to the configurator&lt;/a>&lt;/li>
&lt;li>Register
&lt;a href="#register-plugins">plugins&lt;/a> and/or
&lt;a href="#register-pool-plugins">pool plugins&lt;/a> to be used&lt;/li>
&lt;li>
&lt;a href="#define-profiles">Define profiles&lt;/a> for card resource filtering&lt;/li>
&lt;li>
&lt;a href="#set-allocation-mode">Set the allocation mode&lt;/a> (optional)&lt;/li>
&lt;li>
&lt;a href="#apply-the-configuration">Apply the configuration&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#start-the-service">Start the service&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#allocate-a-resource">Allocate a resource&lt;/a>&lt;/li>
&lt;li>Use the resource&lt;/li>
&lt;li>
&lt;a href="#release-a-resource">Release the used resource&lt;/a>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="access-to-the-service">Access to the service&lt;/h2>
&lt;p>Invoke the &lt;code>CardResourceServiceProvider.getService()&lt;/code> static method to access the service.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('0', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-0">CardResourceService cardResourceService = CardResourceServiceProvider.getService();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="configure-the-service">Configure the service&lt;/h2>
&lt;h3 id="access-to-the-configurator">Access to the configurator&lt;/h3>
&lt;p>Invoke the &lt;code>getConfigurator()&lt;/code> method on the service to get a new instance of the service configurator.
It is built on the fluent pattern, and it guides you through the various steps to be specified during the configuration process.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('1', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-1">cardResourceService.getConfigurator()...&lt;/code>&lt;/pre>
&lt;h3 id="register-plugins">Register plugins&lt;/h3>
&lt;p>If you plan to use plugins of type &lt;code>Plugin&lt;/code> or &lt;code>ObservablePlugin&lt;/code> in the card resource service, you must specify the global ordered list of plugins to be used when searching for a card resource.&lt;/p>
&lt;p>This is the default list that will be applied for profiles that have not explicitly specified another list.&lt;/p>
&lt;p>Please note that the order in which plugins are added is important.&lt;/p>
&lt;p>To add one or more plugins, you need to create a new instance of the &lt;code>PluginsConfigurator&lt;/code> class and provide it to the configurator using the &lt;code>withPlugins(...)&lt;/code> method.&lt;/p>
&lt;p>It is possible to configure the following:&lt;/p>
&lt;ul>
&lt;li>specify the global allocation strategy to all added plugins;&lt;/li>
&lt;li>specify the global usage timeout of a resource;&lt;/li>
&lt;li>activate independently plugin by plugin the monitoring of the plugin and/or its readers in order to allow the service to automatically update the list of resources. In this case you will have to provide a handler to be informed in case of error or crash of the observation thread.&lt;/li>
&lt;/ul>
&lt;p>For each plugin added, you will need to provide an implementation of the &lt;code>ReaderConfiguratorSpi&lt;/code> interface to automatically configure new readers or those already connected.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('2', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-2">.withPlugins(
PluginsConfigurator.builder()
.withAllocationStrategy(...)
.withUsageTimeout(...)
.addPluginWithMonitoring(...)
.addPlugin(...)
.addPluginWithMonitoring(...)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="register-pool-plugins">Register pool plugins&lt;/h3>
&lt;p>If you plan to use plugins of type &lt;code>PoolPlugin&lt;/code> in the card resource service, you must specify the global ordered list of pool plugins to be used when searching for a card resource.&lt;/p>
&lt;p>This is the default list that will be applied for profiles that have not explicitly specified another list.&lt;/p>
&lt;p>Please note that the order in which plugins are added is important.
If you use both plugins and pool plugins in your configuration, it is possible to specify if pool plugins should be taken into account first or not during the resource allocation process.&lt;/p>
&lt;p>To add one or more pool plugins, you need to create a new instance of the &lt;code>PoolPluginsConfigurator&lt;/code> class and provide it to the configurator using the &lt;code>withPoolPlugins(...)&lt;/code> method.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('3', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-3">.withPoolPlugins(
PoolPluginsConfigurator.builder()
.usePoolFirst()
.addPoolPlugin(...)
.addPoolPlugin(...)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="define-profiles">Define profiles&lt;/h3>
&lt;p>A profile defines a set of filters which will be used when enumerating the available resources. The profile identifiers will be used when allocating a resource.&lt;/p>
&lt;p>To add profiles, you must create a new instance of the &lt;code>CardResourceProfileConfigurator&lt;/code> class for each profile and provide them to the configurator using the &lt;code>withCardResourceProfiles(...)&lt;/code> method.&lt;/p>
&lt;p>It is possible to configure the following:&lt;/p>
&lt;ul>
&lt;li>override the global plugin list to use;&lt;/li>
&lt;li>set reader name filter using a regex value;&lt;/li>
&lt;li>set reader group reference filter in case of pool plugins.&lt;/li>
&lt;/ul>
&lt;p>You also need to provide an implementation of the &lt;code>CardResourceProfileExtension&lt;/code> interface in order to be able to customize the filtering if needed and to return to the service an implementation of the &lt;code>SmartCard&lt;/code> interface when a compatible card is found.
The &lt;code>SmartCard&lt;/code> found will be returned to the user by the allocation process.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('4', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-4">.withCardResourceProfiles(
CardResourceProfileConfigurator.builder(RESOURCE_A, yourCardResourceProfileExtensionA)
.withReaderNameRegex(READER_NAME_REGEX_A)
.build(),
CardResourceProfileConfigurator.builder(RESOURCE_B, yourCardResourceProfileExtensionB)
.withReaderNameRegex(READER_NAME_REGEX_B)
.build(),
CardResourceProfileConfigurator.builder(RESOURCE_C, yourCardResourceProfileExtensionC)
.withReaderGroupReference(READER_GROUP_REFERENCE_C)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="set-allocation-mode">Set allocation mode&lt;/h3>
&lt;p>By default, the card resource service is configured with a &lt;strong>non-blocking&lt;/strong> allocation mode.
This means that if no resources are available at the time of the request for an allocation, then the service returns the hand directly.&lt;/p>
&lt;p>The &lt;code>withBlockingAllocationMode(...)&lt;/code> method configure the service to perform allocations in &lt;strong>blocking&lt;/strong> mode so that it only hands over when a resource becomes available.&lt;/p>
&lt;p>You will then have to specify the duration between two search cycles and the maximum waiting time so that the service can always return after a certain time if it has still not found anything.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('5', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-5">.withBlockingAllocationMode(100, 10000) // e.g. search each 100 ms during 10 seconds maximum&lt;/code>&lt;/pre>
&lt;h3 id="apply-the-configuration">Apply the configuration&lt;/h3>
&lt;p>Invoke the &lt;code>configure()&lt;/code> method on the configurator to finalise and apply the configuration.&lt;/p>
&lt;p>Once finalized, the new configuration replaces the previous one but does not change the state of the service.
If the service was already started at that moment, then it stops, applies the new configuration, and restarts.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('6', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-6">.configure();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="use-the-service">Use the service&lt;/h2>
&lt;h3 id="start-the-service">Start the service&lt;/h3>
&lt;p>Invoke the &lt;code>start()&lt;/code> method on the service to start the service using the current configuration.
The service will initialize the list of available resources for each profile and start the monitoring processes if requested.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('7', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-7">cardResourceService.start();&lt;/code>&lt;/pre>
&lt;h3 id="allocate-a-resource">Allocate a resource&lt;/h3>
&lt;p>Invoke the &lt;code>getCardResource(...)&lt;/code> method on the service to retrieve and lock a card resource.
You just have to specify the name of the profile to use.&lt;/p>
&lt;p>If the allocation mode is blocking, then the method will wait a while for a resource to become available.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('8', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-8">CardResource cardResource = cardResourceService.getCardResource(RESOURCE_A);&lt;/code>&lt;/pre>
&lt;h3 id="release-a-resource">Release a resource&lt;/h3>
&lt;p>Invoke the &lt;code>releaseCardResource(...)&lt;/code> method on the service to unlock a card resource.
You just have to provide the card resource to release.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('9', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-9">cardResourceService.releaseCardResource(cardResource);&lt;/code>&lt;/pre>
&lt;h3 id="delete-a-resource">Delete a resource&lt;/h3>
&lt;p>Invoke the &lt;code>removeCardResource(...)&lt;/code> method on the service to remove a card resource from the available card resource list.
This can be useful in some cases if the card or reader has failed.
You just have to provide the card resource to remove.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('10', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-10">cardResourceService.removeCardResource(cardResource);&lt;/code>&lt;/pre>
&lt;h3 id="stop-the-service">Stop the service&lt;/h3>
&lt;p>Invoke the &lt;code>stop()&lt;/code> method on the service to stop the service if needed. Any monitoring is then stopped and no more resources are accessible.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('11', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-11">cardResourceService.stop();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-service-resource-java-lib" target="_blank" rel="noopener">API documentation &amp;amp; class diagram&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="example">Example&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java-example" target="_blank" rel="noopener">Java example&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/keyple-service-resource-java-lib/">Java component&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Create a reader plugin</title><link>https://keyple.org/learn/developer-guide/create-a-reader-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/create-a-reader-plugin/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Create a card extension</title><link>https://keyple.org/learn/developer-guide/create-a-card-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/create-a-card-extension/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item></channel></rss>