<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer guides | Eclipse Keyple</title><link>https://keyple.org/learn/developer-guide/</link><atom:link href="https://keyple.org/learn/developer-guide/index.xml" rel="self" type="application/rss+xml"/><description>Developer guides</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Â© Eclipse Foundation, Inc. All Rights Reserved.</copyright><image><url>https://keyple.org/images/logo_hu673a59176cd62c570f44ed2728665b48_42188_300x300_fit_lanczos_3.png</url><title>Developer guides</title><link>https://keyple.org/learn/developer-guide/</link></image><item><title>Standalone Application Developer Guide</title><link>https://keyple.org/learn/developer-guide/standalone-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/standalone-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A standalone application is an application that runs in a device in contact
with the end user.&lt;/p>
&lt;p>It has at least one local smart card reader and manages itself the
interaction with the user.&lt;/p>
&lt;p>The diagram below illustrates the organization of a standalone application based on Keyple:
&lt;figure >
&lt;a data-fancybox="" href="../../media/learn/developer-guide/standalone-application/Local_Application_Components_Overview.svg" >
&lt;img src="../../media/learn/developer-guide/standalone-application/Local_Application_Components_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;hr>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>If you are new to Keyple, read the
&lt;a href="../../learn/overview/key-concepts/">key concepts&lt;/a> page and familiarize yourself with the fundamentals behind Keyple.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the
setting up of &lt;strong>Keyple Service&lt;/strong>, please study the
&lt;a href="#workflow">workflow&lt;/a> proposed in the following chapter.&lt;/li>
&lt;li>Explore the
&lt;a href="https://keyple.org/components-java/core/keyple-service-java-lib/">Keyple Service component page&lt;/a> to discover the features and the
possibilities offered by its API.&lt;/li>
&lt;li>Take inspiration from the
&lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the
&lt;a href="https://keyple.org/learn/build-your-first-app/java-app/">Build your first app&lt;/a> section to configure your environment (Gradle / Maven).&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/">Java components&lt;/a> pages, import
&lt;strong>Keyple Service&lt;/strong> and the optional add-ons into your project and start playing with &lt;strong>Keyple&lt;/strong>.&lt;/li>
&lt;li>Don&amp;rsquo;t forget to explore the potential of Keyple card-specific
extensions such as
&lt;a href="https://keyple.org/components-java/card-extensions/keyple-card-calypso-java-lib/">&lt;strong>Keyple Calypso&lt;/strong>&lt;/a>.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;ol>
&lt;li>Access to the
&lt;a href="#the-smart-card-service">smart card service&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-up-a-plugin">Set up a plugin&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#set-up-a-reader">Set up a reader&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#select-a-card">Select a card&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#perform-a-transaction">Perform a transaction&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="the-smart-card-service">The smart card service&lt;/h2>
&lt;p>As part of &lt;strong>Keyple Service&lt;/strong> component, the smart card service is the main service of Keyple. Its role is to centralize the add-on resources and to manage their
life cycle.&lt;/p>
&lt;p>The service is accessible by invoking the &lt;code>SmartCardServiceProvider.getService()&lt;/code> static method.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('6', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-6">SmartCardService smartCardService = SmartCardServiceProvider.getService();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="set-up-a-plugin">Set up a plugin&lt;/h2>
&lt;p>The Keyple application developer will choose the reader plugins he needs
according to the equipment on which the Keyple application will run.&lt;/p>
&lt;p>For example, if the environment is PC-based, the PC/SC plugin will probably, but not necessarily, be chosen.
For an Andoid terminal environment, the plugin could be the standard
Android NFC plugin or one of the plugins available from the industrial
partners of the project.&lt;/p>
&lt;p>For a complete list of available plugins, please see
the
&lt;a href="https://keyple.org/components-java/standard-reader-plugins/">standard reader plugins&lt;/a>,
the
&lt;a href="https://keyple.org/components-java/specific-reader-plugins/">specific reader plugins&lt;/a>
or one of our
&lt;a href="https://keyple.org/external-resources/external-add-ons/">partners reader plugins&lt;/a>.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A new plugin can also be &lt;a href="../../learn/developer-guide/create-a-reader-plugin/">created&lt;/a> if there is no plugin for the intended hardware.
&lt;/div>
&lt;/div>
&lt;h3 id="access-to-a-plugin">Access to a plugin&lt;/h3>
&lt;p>To access a plugin at the application level, it must first be registered with the smart card service via the &lt;code>registerPlugin(...)&lt;/code> method.
It will be necessary to provide an implementation of the &lt;code>KeyplePluginExtensionFactory&lt;/code> interface.
This factory is provided by the API of the used plugin.&lt;/p>
&lt;p>Depending on the capabilities of the hardware, the plugin factory may or may not offer specific configuration options.
Please refer to the API of the plugin component you are considering to see what is appropriate for your application.&lt;/p>
&lt;p>The registration provides in return an implementation of one of the &lt;code>Plugin&lt;/code>, &lt;code>ObservablePlugin&lt;/code> or &lt;code>PoolPlugin&lt;/code> interfaces depending on the type of target plugin.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A plugin is identified by a unique name in the system so that it can be retrieved at any time from the smart card service.
&lt;/div>
&lt;/div>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('12', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-12">// Here is for example the registration of the PC/SC plugin
Plugin plugin = smartCardService.registerPlugin(PcscPluginFactoryBuilder.builder().build());&lt;/code>&lt;/pre>
&lt;h3 id="configure-a-plugin">Configure a plugin&lt;/h3>
&lt;p>Some plugin types may offer specific options.&lt;/p>
&lt;p>Static options are usually directly exposed by the plugin factory API while dynamic options are exposed by the plugin extension API.&lt;/p>
&lt;p>To access the plugin extension it is necessary to invoke the &lt;code>getExtension(...)&lt;/code> method on the registered &lt;code>Plugin&lt;/code> by specifying the expected class of the extension which must extends the &lt;code>KeyplePluginExtension&lt;/code> interface.
After that, the dedicated methods are available from the resulting object.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('13', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-13">// Here is a snippet showing the usage of the extension of the Stub plugin
plugin
.getExtension(StubPlugin.class)
.unplugReader(&amp;#34;READER_1&amp;#34;);&lt;/code>&lt;/pre>
&lt;h3 id="monitor-a-plugin">Monitor a plugin&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The plugin monitoring only applies to hardware environments in which the readers are removable.
Moreover, only plugins of type &lt;code>ObservablePlugin&lt;/code> can be monitored.
&lt;/div>
&lt;/div>
&lt;p>The observation of reader connections and disconnections is achieved
through a background task managed by &lt;strong>Keyple Service&lt;/strong>.&lt;/p>
&lt;p>To enable these observation mechanisms, it is imperative to provide:&lt;/p>
&lt;ul>
&lt;li>a plugin observer implementing the &lt;code>PluginObserverSpi&lt;/code> interface to be notified of plugin events,&lt;/li>
&lt;li>an exception handler implementing the &lt;code>PluginObservationExceptionHandlerSpi&lt;/code> interface to be notified of errors that may occur during the monitoring or events notifications.&lt;/li>
&lt;/ul>
&lt;p>These two interfaces are available in the &lt;code>org.eclipse.keyple.core.service.spi&lt;/code> package of the &lt;strong>Keyple Service&lt;/strong> component.&lt;/p>
&lt;p>Here is an example of a plugin observer class including an exception handler:&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('15', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-15">class PluginObserver implements PluginObserverSpi, PluginObservationExceptionHandlerSpi {
@Override
public void onPluginEvent(PluginEvent event) {
switch (event.getEventType()) {
case READER_CONNECTED:
// here the processing to be done when a reader is connected
...
break;
case READER_DISCONNECTED:
// here the processing to be done when a reader is disconnected
...
break;
default:
break;
}
}
@Override
public void onPluginObservationError(String pluginName, Throwable e) {
// handle here the plugin exceptions raised while observing the readers
...
}
}&lt;/code>&lt;/pre>
&lt;p>In order to access the dedicated setters, the plugin has to be cast to &lt;code>ObservablePlugin&lt;/code>.&lt;/p>
&lt;p>Since adding an observer will cause the &lt;strong>Keyple Service&lt;/strong> to check for the presence of an exception handler,
the definition of the exception handler must be done first.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('16', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-16">PluginObserver pluginObserver = new PluginObserver();
((ObservablePlugin) plugin).setPluginObservationExceptionHandler(pluginObserver);
((ObservablePlugin) plugin).addObserver(pluginObserver);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Note that the monitoring thread only works if there is at least one observer registered, and the notification process is sequential and synchronous.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="set-up-a-reader">Set up a reader&lt;/h2>
&lt;p>The readers are provided by the plugins, that&amp;rsquo;s why you have to
&lt;a href="#set-up-a-plugin">set up the plugin&lt;/a> first.&lt;/p>
&lt;h3 id="access-to-a-reader">Access to a reader&lt;/h3>
&lt;p>The hardware readers already connected are referenced in the system during the registration of the plugin.
For observable plugins, the references of the connected readers are updated in real time.&lt;/p>
&lt;p>Readers are accessible directly from the associated &lt;code>Plugin&lt;/code> instance.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('18', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-18">// Here is an example to get the 1st available reader
String readerName = plugin.getReaderNames().get(0);
Reader reader = plugin.getReader(readerName);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Depending on the type of plugin, the reader names are
more or less dynamic (e.g. a PC/SC based system vs. an embedded
terminal), it is sometimes necessary to implement an identification
mechanism in order to assign the right reader to the right place in the
system (for example by using regular expressions).
&lt;/div>
&lt;/div>
&lt;h3 id="configure-a-reader">Configure a reader&lt;/h3>
&lt;p>There are two types of configuration. Their availability depends on the characteristics of the reader:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The reader is an instance of &lt;code>ConfigurableReader&lt;/code>:&lt;br>
It is then possible to activate or deactivate the protocols supported by the reader.&lt;/p>
&lt;div class="alert alert-note">&lt;div>Use of these methods may be optional if the application does not intend to target products by protocol filtering.&lt;/div>&lt;/div>
&lt;/li>
&lt;li>
&lt;p>The reader&amp;rsquo;s extension API exposes specific options:&lt;br>
To access the reader extension it is necessary to invoke the &lt;code>getExtension(...)&lt;/code> method on the &lt;code>Reader&lt;/code> instance by specifying the expected class of the extension which must extends the &lt;code>KeypleReaderExtension&lt;/code> interface.
After that, the dedicated methods, if any, are available from the resulting object.
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('20', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-20">// Here is a snippet showing the usage of the extension of the Stub reader
reader
.getExtension(StubReader.class)
.removeCard();&lt;/code>&lt;/pre>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="monitor-a-reader">Monitor a reader&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The reader monitoring only applies to hardware environments in which the smart cards are removable.
Moreover, only readers of type &lt;code>ObservableReader&lt;/code> can be monitored.
&lt;/div>
&lt;/div>
&lt;div class="alert alert-note">
&lt;div>
Observation of the readers is optional in Keyple. It facilitates an event-driven programming mode, but an application
developer can choose not to observe a reader, either because this reader is not designed to manage card insertions/withdrawals (for example an
Android OMAPI reader or a SAM reader), or because the application is designed to directly manage the presence of a card (see to &lt;code>isCardPresent&lt;/code> method of the
&lt;code>Reader&lt;/code> interface).
&lt;/div>
&lt;/div>
&lt;p>The observation of card insertions and removals is achieved
through a background task managed by &lt;strong>Keyple Service&lt;/strong>.&lt;/p>
&lt;p>To enable these observation mechanisms, it is imperative to provide:&lt;/p>
&lt;ul>
&lt;li>a reader observer implementing the &lt;code>CardReaderObserverSpi&lt;/code> interface to be notified of reader events,&lt;/li>
&lt;li>an exception handler implementing the &lt;code>CardReaderObservationExceptionHandlerSpi&lt;/code> interface to be notified of errors that may occur during the monitoring or events notifications.&lt;/li>
&lt;/ul>
&lt;p>These two interfaces are available in the &lt;code>org.calypsonet.terminal.reader.spi&lt;/code> package of the &lt;strong>Calypsonet Terminal Reader API&lt;/strong> component.&lt;/p>
&lt;p>Here is an example of a reader observer class including an exception handler:&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('23', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-23">class ReaderObserver implements CardReaderObserverSpi, CardReaderObservationExceptionHandlerSpi {
@Override
public void onReaderEvent(CardReaderEvent event) {
switch (event.getType()) {
case CardReaderEvent.Type.CARD_INSERTED:
// here the processing to be done when a card is inserted
...
break;
case CardReaderEvent.Type.CARD_REMOVED:
// here the processing to be done when a card is removed
...
break;
default:
break;
}
}
@Override
public void onReaderObservationError(String pluginName, String readerName, Throwable e) {
// handle here the reader exceptions raised while observing the cards
...
}
}&lt;/code>&lt;/pre>
&lt;p>In order to access the dedicated setters, the reader has to be cast to &lt;code>ObservableReader&lt;/code>.&lt;/p>
&lt;p>Since adding an observer will cause the &lt;strong>Keyple Service&lt;/strong> to check for the presence of an exception handler,
the definition of the exception handler must be done first.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('24', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-24">ReaderObserver readerObserver = new ReaderObserver();
((ObservableReader) reader).setReaderObservationExceptionHandler(readerObserver);
((ObservableReader) reader).addObserver(readerObserver);
((ObservableReader) reader).startCardDetection(ObservableCardReader.DetectionMode.REPEATING);&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Note that the &lt;code>startCardDetection(...)&lt;/code> and &lt;code>stopCardDetection()&lt;/code> methods start and stop the monitoring thread.
The API offers different options to manage the needs around card detection.&lt;br>
Moreover, the notification process is sequential and synchronous.
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="select-a-card">Select a card&lt;/h2>
&lt;p>The starting point of any processing done with a card in the Keyple enrivonment, is to reference this card in the system.
It is the role of the selection step to obtain this reference.&lt;/p>
&lt;p>You have first to prepare a selection scenario defining the eligible cards for a transaction, then to execute the scenario when a card is present.&lt;/p>
&lt;h3 id="prepare-a-scenario">Prepare a scenario&lt;/h3>
&lt;p>To prepare a scenario, you have to get a new instance of &lt;code>CardSelectionManager&lt;/code> from the smart card service using the &lt;code>createCardSelectionManager()&lt;/code> method,
then configure it with scenario cases using dedicated methods provided by one or more card extensions.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('26', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-26">CardSelectionManager cardSelectionManager = smartCardService.createCardSelectionManager();```&lt;/code>&lt;/pre>
&lt;p>The &lt;code>prepareSelection(...)&lt;/code> method allows to add a selection case to the scenario by providing an implementation of the &lt;code>CardSelection&lt;/code> interface and return the index of the added case in order to be able to identify later the case that matched.&lt;/p>
&lt;p>Please note that the order of addition is important because it will impact the selection cycle and favor the performance of the first added cases.&lt;/p>
&lt;p>Providing one or more selection cases to the &lt;code>CardSelectionManager&lt;/code> constitutes a selection scenario.
The scenario is run by &lt;strong>Keyple Service&lt;/strong> when a card is detected, the different cases being evaluated
sequentially as long as the card does not match the criteria of the defined cases.&lt;/p>
&lt;p>The selection process for a case offers several options for selecting a processing based on the type of card presented to the reader.&lt;/p>
&lt;p>It is based on a filtering process according to three possible criteria,
each of which is optional:&lt;/p>
&lt;ul>
&lt;li>the communication protocol of the card (usually also identifying a
card technology)&lt;/li>
&lt;li>the power-on data collected by the reader when the card is detected (e.g. the Answer To Reset)&lt;/li>
&lt;li>the ISO standard application identifier (AID) used to perform a Select Application command.&lt;/li>
&lt;/ul>
&lt;p>When a card is inserted, it is evaluated according to these criteria and
will be given the status &amp;ldquo;selected&amp;rdquo; or not.&lt;/p>
&lt;p>When a card is not selected, no other operation will be possible with it.&lt;/p>
&lt;p>The same card could correspond to several cases of the same scenario, especially when filtering by AID.
By default, the selection process will stop at the first case that matches.
It is however possible to choose another strategy using the &lt;code>setMultipleSelectionMode()&lt;/code> method.
In this case, the process will continue to the last selection case in the scenario and return all results, but only the last matching application will be selected.&lt;/p>
&lt;p>When a card is selected, the &lt;code>CardSelectionManager&lt;/code> will make available the result
as a &lt;code>SmartCard&lt;/code> object containing all the information known about the card at that stage.&lt;/p>
&lt;p>Depending on the card extension that is used, this &lt;code>SmartCard&lt;/code> object can be cast to a more
comprehensive object with specific features defined by the extension.&lt;/p>
&lt;p>In addition to the selection process itself, specific APDU commands may be sent to the card if the selection is successful.
The output of these commands is available in the instance of the &lt;code>SmartCard&lt;/code> object.&lt;/p>
&lt;p>The following snippet shows the preparation of two selection cases using the generic card extension:
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('27', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-27">// prepare a selection for application 1
int firstCaseIndex = cardSelectionManager.prepareSelection(
GenericExtensionService.getInstance()
.createCardSelection()
.filterByDfName(AID1));
// prepare a selection for application 2
int secondCaseIndex = cardSelectionManager.prepareSelection(
GenericExtensionService.getInstance()
.createCardSelection()
.filterByDfName(AID2));&lt;/code>&lt;/pre>&lt;/p>
&lt;h3 id="run-a-scenario">Run a scenario&lt;/h3>
&lt;p>If we know that the card is in the reader it is possible to run a selection scenario by invoking the &lt;code>processCardSelectionScenario(...)&lt;/code> method on the corresponding reader.
The result of the selection is then directly returned.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('28', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-28">// Actual card communication: run the selection scenario.
CardSelectionResult selectionResult = cardSelectionManager.processCardSelectionScenario(reader);
// Check the selection result.
if (selectionResult.getActiveSmartCard() == null) {
throw new IllegalStateException(&amp;#34;The selection of the card failed.&amp;#34;);
}
// Get the SmartCard resulting of the selection.
SmartCard smartCard = selectionResult.getActiveSmartCard();&lt;/code>&lt;/pre>
&lt;h3 id="schedule-a-scenario">Schedule a scenario&lt;/h3>
&lt;p>If the reader is of type &lt;code>ObservableReader&lt;/code> then it is possible to schedule in advance the execution of a selection scenario as soon as a card is presented.&lt;/p>
&lt;p>Invoke the &lt;code>scheduleCardSelectionScenario(...)&lt;/code> to register the previously prepared scenario in the observable reader.&lt;/p>
&lt;p>In this case, it is necessary to register a reader observer and to have started the card detection in order to be able to retrieve the result of the selection which will be contained in a &lt;code>ReaderEvent&lt;/code>.&lt;/p>
&lt;p>Use the &lt;code>parseScheduledCardSelectionsResponse(...)&lt;/code> method to extract the selection result from the event.&lt;/p>
&lt;p>Note that the scheduling of the execution of a scenario includes two options:&lt;/p>
&lt;ul>
&lt;li>the &lt;code>DetectionMode&lt;/code> defining the expected behavior regarding the card detection allowing to automatically restart it or not.&lt;/li>
&lt;li>the &lt;code>NotificationMode&lt;/code> allowing to choose if only the cards matching the selection (successfully selected) should trigger an event.&lt;/li>
&lt;/ul>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('29', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-29">...
@Override
public void onReaderEvent(CardReaderEvent event) {
switch (event.getType()) {
case CardReaderEvent.Type.CARD_MATCHED:
// Retrieve the selected smart card
SmartCard smartCard =
cardSelectionManager
.parseScheduledCardSelectionsResponse(event.getScheduledCardSelectionsResponse())
.getActiveSmartCard();
// Perform the transaction
...
break;
default:
break;
}
if (event.getType() == CardReaderEvent.Type.CARD_INSERTED
|| event.getType() == CardReaderEvent.Type.CARD_MATCHED) {
// Ensures that the communication channel is closed, regardless of the processing with the card.
((ObservableReader) (reader)).finalizeCardProcessing();
}
}
...&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
&lt;p>The &lt;code>finalizeCardProcessing()&lt;/code> method must be invoked at the end of the transaction to ensure that the communication channel is closed.
This switches the underlying monitoring thread into a state of waiting for the card to be removed.&lt;/p>
&lt;p>Not doing this can lead to blocking states of the card insertion/removal monitoring mechanism.&lt;/p>
&lt;/div>
&lt;/div>
&lt;hr>
&lt;h2 id="perform-a-transaction">Perform a transaction&lt;/h2>
&lt;p>Once the smart card is referenced in the system it is possible to perform the desired transaction using the appropriate card extension.&lt;/p>
&lt;p>When the transaction is completed, if the reader is observed, it is imperative to invoke the &lt;code>finalizeCardProcessing()&lt;/code> method on the observable reader (see the above note).&lt;/p>
&lt;hr>
&lt;h2 id="unregister-a-plugin">Unregister a plugin&lt;/h2>
&lt;p>To shut down a Keyple application properly, it is necessary to free the resources and in particular to stop the observation threads.&lt;/p>
&lt;p>This is done by unregistering the plugins in the following way:&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('31', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-31">smartCardService.unregisterPlugin(plugin.getName());&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://calypsonet.github.io/calypsonet-terminal-reader-java-api" target="_blank" rel="noopener">Calypsonet Terminal Reader API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-common-java-api" target="_blank" rel="noopener">Keyple Common API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-service-java-lib" target="_blank" rel="noopener">Keyple Service API&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java-example" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/overview/configuration-wizard/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Distributed Application Developer Guide</title><link>https://keyple.org/learn/developer-guide/distributed-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/distributed-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Keyple provides the &amp;ldquo;Keyple Distributed&amp;rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal&lt;/strong>.&lt;/p>
&lt;p>In this way, you can manage transactions within a distributed architecture.&lt;/p>
&lt;p>The diagram below shows the location of the &lt;strong>Keyple Distributed&lt;/strong> components in the software layers used in a distributed architecture:&lt;/p>
&lt;figure id="figure-keyple-distributed---solution-layers-overview">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_solution_layers_overview.svg" data-caption="Keyple Distributed - Solution layers overview">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_solution_layers_overview.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Solution layers overview
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="how-to-use-it-">How to use it ?&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read
&lt;a href="../../learn/developer-guide/standalone-application/">Standalone Application Developer Guide&lt;/a> to understand the main concepts of Keyple in a standalone application.&lt;/li>
&lt;li>Read chapter
&lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/li>
&lt;li>Using chapter
&lt;a href="#usage-modes">Usage modes&lt;/a>, find your usage mode. This will help you to determine exactly which library and API to use.&lt;/li>
&lt;li>Using chapter
&lt;a href="#download">Download&lt;/a>, import into your project the libraries specified by your usage mode.&lt;/li>
&lt;li>Using chapter
&lt;a href="#network-configuration">Network configuration&lt;/a>, implement the transport layer adapted to your network configuration.&lt;/li>
&lt;li>Implement your ticketing services as specified in the associated usage mode.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this developer guide:&lt;/p>
&lt;div id="concepts-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Concept&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Remote Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-remote-java-lib&lt;/code> library.&lt;br>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-local-java-lib&lt;/code> library.&lt;br>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Lib&lt;/strong>&lt;/td>
&lt;td>This is the &lt;code>keyple-distributed-network-java-lib&lt;/code> library.&lt;br>It must always be imported because it contains the network elements used by &lt;strong>Remote Lib&lt;/strong> and &lt;strong>Local Lib&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple reader plugin extension which provides only &lt;strong>Remote Readers&lt;/strong> to the application. It manages data exchanges with the &lt;strong>Local Service&lt;/strong>. This reader plugin extension must be registered to the smart card service like any Keyple reader plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Reader&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple reader extension which has some specificities:&lt;br>- each remote reader is connected to a local reader;&lt;br>- any command sent by the application to a remote reader will be forwarded to the associated local reader;&lt;br>- in some cases only, an event occurring on a local reader or plugin will be automatically forwarded to the associated remote reader or plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Local Lib&lt;/strong>, this is a Keyple distributed local service extension which ensures data exchange between the &lt;strong>Remote Plugin&lt;/strong> and local plugins and readers. It must be registered to the smart card service.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific factory class to initialize them.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each are bind to a specific internal node which is responsible for the interfacing with the &lt;strong>Network Endpoint&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Endpoint&lt;/strong>&lt;/td>
&lt;td>At the user&amp;rsquo;s charge, this component ensures the network exchanges between the &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> nodes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#concepts-table-1 table th:first-of-type {
width: 130px;
}
&lt;/style>
&lt;p>The diagram below illustrates the main functional concepts through a standard use case:&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---main-use-case">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_1.svg" data-caption="Keyple Distributed - Concepts - Main use case">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_1.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - Main use case
&lt;/figcaption>
&lt;/figure>
&lt;p>The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.&lt;/p>
&lt;p>These could be for example a ticketing reloading service, where the business logic would be on the terminal without local readers, with thin clients on A &amp;amp; B terminals communicating locally with the cards.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for card communication.&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---one-remote-plugin-connected-to-many-local-services">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_2.svg" data-caption="Keyple Distributed - Concepts - One remote plugin connected to many local services">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_2.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - One remote plugin connected to many local services
&lt;/figcaption>
&lt;/figure>
&lt;p>Here is another example, but this time it illustrates several remote plugins connected to the same local service.&lt;/p>
&lt;p>These could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for SAM communication.&lt;/p>
&lt;figure id="figure-keyple-distributed---concepts---many-remote-plugins-connected-to-one-local-service">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_concepts_3.svg" data-caption="Keyple Distributed - Concepts - Many remote plugins connected to one local service">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_concepts_3.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Concepts - Many remote plugins connected to one local service
&lt;/figcaption>
&lt;/figure>
&lt;hr>
&lt;h2 id="usage-modes">Usage modes&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution offers two different usage modes, each one having a specific API designed on a &lt;strong>Client-Server&lt;/strong> model:&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Usage mode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#reader-client-side">Reader Client Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. Card reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#reader-server-side">Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader, HSM).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 190px;
}
&lt;/style>
&lt;p>Each mode provides a different &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> and their associated factories.&lt;/p>
&lt;p>In an application, it is possible to use simultaneously several usage modes and as many instances of a usage mode as you want, as long as the components are initialized with different names.&lt;/p>
&lt;h3 id="reader-client-side">Reader Client Side&lt;/h3>
&lt;p>This usage mode allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. Card reader).&lt;/p>
&lt;p>In this mode, the client is the initiator of the application processing following the local plugin or reader events (reader connection/disconnection or card insertion/removal).&lt;/p>
&lt;p>He can hand over to the server whenever he wants to perform a remote ticketing service on a card present in one of his local readers.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service / Remote Plugin&lt;/strong>&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;td>&lt;code>ObservablePlugin&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service / Remote Plugin extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClient&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;td>&lt;code>RemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-warning">
&lt;div>
It is the responsibility of the client application to observe and configure the local plugins and readers.
&lt;/div>
&lt;/div>
&lt;h4 id="operating-mode">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Server&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>RemotePluginServerFactory&lt;/code> using the &lt;code>RemotePluginServerFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Remote Plugin&lt;/strong> to be registered and your network endpoint implementation if required.&lt;/li>
&lt;li>Register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Cast the registered plugin into an &lt;code>ObservablePlugin&lt;/code> and add an event observer to it.&lt;br>&lt;div class="alert alert-note">&lt;div>Please note that this remote plugin is observable only to trigger ticketing services on the server side, but does not allow observation on the local plugin such as reader connection or disconnection.&lt;/div>&lt;/div>&lt;/li>
&lt;li>Await for events of type &lt;code>PluginEvent.Type.READER_CONNECTED&lt;/code>.&lt;br>&lt;div class="alert alert-note">&lt;div>This type of event indicates to the server that a client asks it to perform a specific ticketing service using the connected remote reader.&lt;/div>&lt;/div>&lt;/li>
&lt;li>When an event occurs, you must retrieve the connected remote reader from the registered plugin using the name of the reader contained in the event.&lt;br>&lt;div class="alert alert-note">&lt;div>Please note that the remote reader is strictly an instance of &lt;code>Reader&lt;/code>, even if the local reader is an &lt;code>ObservableReader&lt;/code>.&lt;br>This usage mode does not allow to observe reader events such as card insertion or removal from the server.&lt;br>It is the responsibility of the client to observe the local reader if needed, then to ask the server to execute a specific remote service depending on the case.&lt;/div>&lt;/div>&lt;/li>
&lt;li>Use information inside the &lt;code>RemoteReaderServer&lt;/code> extension of the remote reader to identify the ticketing service to execute.&lt;/li>
&lt;li>Execute the specified ticketing service using the remote reader and all of its other information.&lt;/li>
&lt;li>End the remote ticketing service by invoking the associated method provided by the &lt;code>RemotePluginServer&lt;/code> extension of the remote plugin.&lt;br>It is then possible to send additional information to the client if necessary.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Client&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>LocalServiceClientFactory&lt;/code> using the &lt;code>LocalServiceClientFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Local Service&lt;/strong> to be registered and your network endpoint implementation.&lt;/li>
&lt;li>Register the &lt;strong>Local Service&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Register at least a local plugin to the smart card service and get the name of the local reader to connect to the server.&lt;/li>
&lt;li>Execute the desired remote service by invoking the associated method provided by the &lt;code>LocalServiceClient&lt;/code> extension of the local service by specifying the identifier of the ticketing service to be executed, the name of the target local reader, and transmitting to the server if necessary the contents of the previously read smart card or additional information.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="reader-server-side">Reader Server Side&lt;/h3>
&lt;p>This usage mode allows a &lt;strong>client&lt;/strong> application to control a smart card reader or a pool of smart card readers available on a &lt;strong>server&lt;/strong> (e.g. SAM reader, HSM).&lt;/p>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution offers for this usage mode a remote control of all types of plugins (&lt;code>Plugin&lt;/code>, &lt;code>ObservablePlugin&lt;/code>, &lt;code>PoolPlugin&lt;/code>):&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Regular plugin&lt;/strong> (&lt;code>Plugin&lt;/code> or &lt;code>ObservablePlugin&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>During the remote plugin registration process, the client automatically creates a remote reader for each local reader of the set of local plugins on the server.&lt;/p>
&lt;p>If the factory has been properly configured, then the remote plugin and reader behave like the local plugins and readers.&lt;/p>
&lt;p>It is then possible to observe directly from the client the plugin and/or reader events (reader connection/disconnection or card insertion/removal) if desired.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode in the case of a &lt;strong>regular plugin&lt;/strong>.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>Plugin&lt;/code> * or&lt;br>&lt;code>ObservablePlugin&lt;/code> *&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> * or&lt;br>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemoteReaderClient&lt;/code>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>Pool plugin&lt;/strong> (&lt;code>PoolPlugin&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>The dynamic reader allocation process will search for the first available reader among all or a subset of the pool plugins registered on the server.&lt;/p>
&lt;p>It is possible to define during the configuration phase of the local service factory a filter on the names of the pool plugins to use.&lt;/p>
&lt;p>The table below shows the classes and interfaces available for this usage mode in the case of a &lt;strong>pool plugin&lt;/strong>.&lt;br>
Interfaces marked with an asterisk &amp;ldquo;*&amp;rdquo; come from the &lt;strong>Keyple Service API&lt;/strong>:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library to use&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory builder to be used&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePoolPluginClientFactoryBuilder&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactoryBuilder&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory to be registered&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolPlugin&lt;/code> *&lt;/td>
&lt;td>&lt;code>DistributedLocalService&lt;/code> *&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin / Local Service extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader&lt;/strong>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> *&lt;/td>
&lt;td>Any kind of reader&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Reader extension&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemoteReaderClient&lt;/code>&lt;/td>
&lt;td>Device specific&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="alert alert-warning">
&lt;div>
Whatever the type of plugin, it is the responsibility of the server application to configure the local plugins and readers.
&lt;/div>
&lt;/div>
&lt;h4 id="operating-mode-1">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Server&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>LocalServiceServerFactory&lt;/code> using the &lt;code>LocalServiceServerFactoryBuilder&lt;/code> class, specifying a unique name for the &lt;strong>Local Service&lt;/strong> to be registered and your network endpoint implementation if required.&lt;/li>
&lt;li>Register the &lt;strong>Local Service&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Register at least a local plugin or pool plugin to the smart card service, depending on your case.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>Client&lt;/strong>
&lt;ol>
&lt;li>Build an instance of the &lt;code>RemotePluginClientFactory&lt;/code> using the &lt;code>RemotePluginClientFactoryBuilder&lt;/code> or &lt;code>RemotePoolPluginClientFactoryBuilder&lt;/code> class depends on the type of plugin that you want to manage, specifying a unique name for the &lt;strong>Remote Plugin&lt;/strong> to be registered and your network endpoint implementation.&lt;/li>
&lt;li>Register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service by providing the previously built factory.&lt;/li>
&lt;li>Use the registered remote plugin as a local plugin.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="network-configuration">Network configuration&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution &lt;strong>does not provide&lt;/strong> the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components.&lt;/p>
&lt;h3 id="synchronous">Synchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Client-Server &lt;strong>Synchronous&lt;/strong> communication protocol, such as standard HTTP for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Network endpoint SPI to be implemented&lt;/td>
&lt;td>&lt;code>SyncEndpointClientSpi&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>SyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>SyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withSyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method provided by the remote plugin or local service extension&lt;br>to use to access the node&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>getSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement in a context with a &lt;strong>single server instance&lt;/strong>:&lt;/p>
&lt;figure id="figure-keyple-distributed---synchronous-network-implementation">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_synchronous.svg" data-caption="Keyple Distributed - Synchronous network implementation">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_synchronous.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Synchronous network implementation
&lt;/figcaption>
&lt;/figure>
&lt;p>In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a &lt;code>serverNodeId&lt;/code> are routed to the server associated with a &lt;code>SyncNodeServer&lt;/code> node having the &lt;code>serverNodeId&lt;/code>.&lt;/p>
&lt;h3 id="asynchronous">Asynchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Full-Duplex &lt;strong>Asynchronous&lt;/strong> communication protocol, such as Web Sockets for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Network endpoint SPI to be implemented&lt;/td>
&lt;td>&lt;code>AsyncEndpointClientSpi&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncEndpointServerSpi&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>AsyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Method provided by the remote plugin or local service extension&lt;br>to use to access the node&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code>&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement:&lt;/p>
&lt;figure id="figure-keyple-distributed---asynchronous-network-implementation">
&lt;a data-fancybox="" href="../../media/learn/developer-guide/distributed-application/distributed_asynchronous.svg" data-caption="Keyple Distributed - Asynchronous network implementation">
&lt;img src="../../media/learn/developer-guide/distributed-application/distributed_asynchronous.svg" alt="" >
&lt;/a>
&lt;figcaption data-pre="Figure " data-post=":" class="numbered">
Keyple Distributed - Asynchronous network implementation
&lt;/figcaption>
&lt;/figure>
&lt;h3 id="exchanged-data">Exchanged data&lt;/h3>
&lt;p>The data exchanged between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components are contained in the DTO (Data Transfer Object) &lt;code>MessageDto&lt;/code>. It is built and processed by the plugin and &lt;strong>you don&amp;rsquo;t need to modify it&lt;/strong>.&lt;/p>
&lt;p>However, it is necessary in some contexts to access certain information such as the &lt;code>sessionId&lt;/code> in the case of asynchronous communication or the &lt;code>serverNodeId&lt;/code> in the case of synchronous communication with several server instances.&lt;/p>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-local-java-lib" target="_blank" rel="noopener">Local API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-network-java-lib" target="_blank" rel="noopener">Network API&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-distributed-remote-java-lib" target="_blank" rel="noopener">Remote API&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java-example" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/distributed/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso application</title><link>https://keyple.org/learn/developer-guide/calypso-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/calypso-application/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Card Resource Service Developer Guide</title><link>https://keyple.org/learn/developer-guide/card-resource-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/card-resource-service/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>An application that performs secure transactions on smart cards may need to dynamically allocate a card resource dedicated to the current transaction to manage the security of the transaction (e.g. SAM or HSM).&lt;/p>
&lt;p>To meet this need, Keyple proposes the &lt;strong>Service Resource&lt;/strong> component which provides a service that supports dynamic card resource allocation, using a profile-based filtering mechanism.&lt;/p>
&lt;hr>
&lt;h2 id="features">Features&lt;/h2>
&lt;ul>
&lt;li>card resource locking during use;&lt;/li>
&lt;li>automatic monitoring of observable plugins and readers;&lt;/li>
&lt;li>customizable profile-based filtering mechanism (specific plugins list, reader name using regular expression, reader group name for pool plugins, specific card selection);&lt;/li>
&lt;li>specific reader configuration capability;&lt;/li>
&lt;li>allocation priority management;&lt;/li>
&lt;li>two allocation modes (blocking, non-blocking);&lt;/li>
&lt;li>multiple allocation strategies (first available card resource, cyclic, random);&lt;/li>
&lt;li>configurable allocation timeout;&lt;/li>
&lt;li>failure management.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="operating-mode">Operating mode&lt;/h2>
&lt;ol>
&lt;li>
&lt;a href="#access-to-the-service">Access to the service&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#access-to-the-configurator">Access to the configurator&lt;/a>&lt;/li>
&lt;li>Register
&lt;a href="#register-plugins">plugins&lt;/a> and/or
&lt;a href="#register-pool-plugins">pool plugins&lt;/a> to be used&lt;/li>
&lt;li>
&lt;a href="#define-profiles">Define profiles&lt;/a> for card resource filtering&lt;/li>
&lt;li>
&lt;a href="#set-allocation-mode">Set the allocation mode&lt;/a> (optional)&lt;/li>
&lt;li>
&lt;a href="#apply-the-configuration">Apply the configuration&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#start-the-service">Start the service&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#allocate-a-resource">Allocate a resource&lt;/a>&lt;/li>
&lt;li>Use the resource&lt;/li>
&lt;li>
&lt;a href="#release-a-resource">Release the used resource&lt;/a>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="access-to-the-service">Access to the service&lt;/h2>
&lt;p>Invoke the &lt;code>CardResourceServiceProvider.getService()&lt;/code> static method to access the service.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('0', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-0">CardResourceService cardResourceService = CardResourceServiceProvider.getService();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="configure-the-service">Configure the service&lt;/h2>
&lt;h3 id="access-to-the-configurator">Access to the configurator&lt;/h3>
&lt;p>Invoke the &lt;code>getConfigurator()&lt;/code> method on the service to get a new instance of the service configurator.
It is built on the fluent pattern, and it guides you through the various steps to be specified during the configuration process.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('1', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-1">cardResourceService.getConfigurator()...&lt;/code>&lt;/pre>
&lt;h3 id="register-plugins">Register plugins&lt;/h3>
&lt;p>If you plan to use plugins of type &lt;code>Plugin&lt;/code> or &lt;code>ObservablePlugin&lt;/code> in the card resource service, you must specify the global ordered list of plugins to be used when searching for a card resource.&lt;/p>
&lt;p>This is the default list that will be applied for profiles that have not explicitly specified another list.&lt;/p>
&lt;p>Please note that the order in which plugins are added is important.&lt;/p>
&lt;p>To add one or more plugins, you need to create a new instance of the &lt;code>PluginsConfigurator&lt;/code> class and provide it to the configurator using the &lt;code>withPlugins(...)&lt;/code> method.&lt;/p>
&lt;p>It is possible to configure the following:&lt;/p>
&lt;ul>
&lt;li>specify the global allocation strategy to all added plugins;&lt;/li>
&lt;li>specify the global usage timeout of a resource;&lt;/li>
&lt;li>activate independently plugin by plugin the monitoring of the plugin and/or its readers in order to allow the service to automatically update the list of resources. In this case you will have to provide a handler to be informed in case of error or crash of the observation thread.&lt;/li>
&lt;/ul>
&lt;p>For each plugin added, you will need to provide an implementation of the &lt;code>ReaderConfiguratorSpi&lt;/code> interface to automatically configure new readers or those already connected.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('2', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-2">.withPlugins(
PluginsConfigurator.builder()
.withAllocationStrategy(...)
.withUsageTimeout(...)
.addPluginWithMonitoring(...)
.addPlugin(...)
.addPluginWithMonitoring(...)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="register-pool-plugins">Register pool plugins&lt;/h3>
&lt;p>If you plan to use plugins of type &lt;code>PoolPlugin&lt;/code> in the card resource service, you must specify the global ordered list of pool plugins to be used when searching for a card resource.&lt;/p>
&lt;p>This is the default list that will be applied for profiles that have not explicitly specified another list.&lt;/p>
&lt;p>Please note that the order in which plugins are added is important.
If you use both plugins and pool plugins in your configuration, it is possible to specify if pool plugins should be taken into account first or not during the resource allocation process.&lt;/p>
&lt;p>To add one or more pool plugins, you need to create a new instance of the &lt;code>PoolPluginsConfigurator&lt;/code> class and provide it to the configurator using the &lt;code>withPoolPlugins(...)&lt;/code> method.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('3', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-3">.withPoolPlugins(
PoolPluginsConfigurator.builder()
.usePoolFirst()
.addPoolPlugin(...)
.addPoolPlugin(...)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="define-profiles">Define profiles&lt;/h3>
&lt;p>A profile defines a set of filters which will be used when enumerating the available resources. The profile identifiers will be used when allocating a resource.&lt;/p>
&lt;p>To add profiles, you must create a new instance of the &lt;code>CardResourceProfileConfigurator&lt;/code> class for each profile and provide them to the configurator using the &lt;code>withCardResourceProfiles(...)&lt;/code> method.&lt;/p>
&lt;p>It is possible to configure the following:&lt;/p>
&lt;ul>
&lt;li>override the global plugin list to use;&lt;/li>
&lt;li>set reader name filter using a regex value;&lt;/li>
&lt;li>set reader group reference filter in case of pool plugins.&lt;/li>
&lt;/ul>
&lt;p>You also need to provide an implementation of the &lt;code>CardResourceProfileExtension&lt;/code> interface in order to be able to customize the filtering if needed and to return to the service an implementation of the &lt;code>SmartCard&lt;/code> interface when a compatible card is found.
The &lt;code>SmartCard&lt;/code> found will be returned to the user by the allocation process.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('4', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-4">.withCardResourceProfiles(
CardResourceProfileConfigurator.builder(RESOURCE_A, yourCardResourceProfileExtensionA)
.withReaderNameRegex(READER_NAME_REGEX_A)
.build(),
CardResourceProfileConfigurator.builder(RESOURCE_B, yourCardResourceProfileExtensionB)
.withReaderNameRegex(READER_NAME_REGEX_B)
.build(),
CardResourceProfileConfigurator.builder(RESOURCE_C, yourCardResourceProfileExtensionC)
.withReaderGroupReference(READER_GROUP_REFERENCE_C)
.build())&lt;/code>&lt;/pre>
&lt;h3 id="set-allocation-mode">Set allocation mode&lt;/h3>
&lt;p>By default, the card resource service is configured with a &lt;strong>non-blocking&lt;/strong> allocation mode.
This means that if no resources are available at the time of the request for an allocation, then the service returns the hand directly.&lt;/p>
&lt;p>The &lt;code>withBlockingAllocationMode(...)&lt;/code> method configure the service to perform allocations in &lt;strong>blocking&lt;/strong> mode so that it only hands over when a resource becomes available.&lt;/p>
&lt;p>You will then have to specify the duration between two search cycles and the maximum waiting time so that the service can always return after a certain time if it has still not found anything.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('5', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-5">.withBlockingAllocationMode(100, 10000) // e.g. search each 100 ms during 10 seconds maximum&lt;/code>&lt;/pre>
&lt;h3 id="apply-the-configuration">Apply the configuration&lt;/h3>
&lt;p>Invoke the &lt;code>configure()&lt;/code> method on the configurator to finalise and apply the configuration.&lt;/p>
&lt;p>Once finalized, the new configuration replaces the previous one but does not change the state of the service.
If the service was already started at that moment, then it stops, applies the new configuration, and restarts.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('6', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-6">.configure();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="use-the-service">Use the service&lt;/h2>
&lt;h3 id="start-the-service">Start the service&lt;/h3>
&lt;p>Invoke the &lt;code>start()&lt;/code> method on the service to start the service using the current configuration.
The service will initialize the list of available resources for each profile and start the monitoring processes if requested.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('7', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-7">cardResourceService.start();&lt;/code>&lt;/pre>
&lt;h3 id="allocate-a-resource">Allocate a resource&lt;/h3>
&lt;p>Invoke the &lt;code>getCardResource(...)&lt;/code> method on the service to retrieve and lock a card resource.
You just have to specify the name of the profile to use.&lt;/p>
&lt;p>If the allocation mode is blocking, then the method will wait a while for a resource to become available.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('8', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-8">CardResource cardResource = cardResourceService.getCardResource(RESOURCE_A);&lt;/code>&lt;/pre>
&lt;h3 id="release-a-resource">Release a resource&lt;/h3>
&lt;p>Invoke the &lt;code>releaseCardResource(...)&lt;/code> method on the service to unlock a card resource.
You just have to provide the card resource to release.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('9', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-9">cardResourceService.releaseCardResource(cardResource);&lt;/code>&lt;/pre>
&lt;h3 id="delete-a-resource">Delete a resource&lt;/h3>
&lt;p>Invoke the &lt;code>removeCardResource(...)&lt;/code> method on the service to remove a card resource from the available card resource list.
This can be useful in some cases if the card or reader has failed.
You just have to provide the card resource to remove.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('10', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-10">cardResourceService.removeCardResource(cardResource);&lt;/code>&lt;/pre>
&lt;h3 id="stop-the-service">Stop the service&lt;/h3>
&lt;p>Invoke the &lt;code>stop()&lt;/code> method on the service to stop the service if needed. Any monitoring is then stopped and no more resources are accessible.&lt;/p>
&lt;div class="bd-clipboard">&lt;button type="button" class="btn btn-clipboard btn-outline-light" title="Copy to clipboard" onClick="javascript:copyCodeContentToClipboard('11', this);">Copy&lt;/button>&lt;/div>
&lt;pre>&lt;code class="language-java" id="code-11">cardResourceService.stop();&lt;/code>&lt;/pre>
&lt;hr>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://eclipse.github.io/keyple-service-resource-java-lib" target="_blank" rel="noopener">API documentation &amp;amp; class diagram&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="example">Example&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java-example" target="_blank" rel="noopener">Java example&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/keyple-service-resource-java-lib/">Java component&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Create a reader plugin</title><link>https://keyple.org/learn/developer-guide/create-a-reader-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/create-a-reader-plugin/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Create a card extension</title><link>https://keyple.org/learn/developer-guide/create-a-card-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/learn/developer-guide/create-a-card-extension/</guid><description>&lt;hr>
&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item></channel></rss>